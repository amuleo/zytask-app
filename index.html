<!DOCTYPE html>
<html lang="fa" dir="rtl">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>زای تسک</title>
    <meta name="robots" content="noindex, nofollow">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/manifest.json">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="زای تسک">

    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/gh/rastikerdar/vazirmatn@33.003/misc/Farsi-Digits/Vazirmatn-FD-font-face.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css"
        xintegrity="sha512-DTOQO9RWCH3ppGqcWaEA1BIZOC6xxalwEsw9c2QQeAIftl+Vegovlnee1c9QX4TctnWMn13TZye+giMm8e2LwA=="
        crossorigin="anonymous" referrerpolicy="no-referrer" />

    <style>
        /* CSS variables for dynamic theming (Updated to Blue Theme) */
        :root {
            /* Light mode colors (Blue theme) */
            --theme-primary: #2563eb; /* blue-600 */
            --theme-secondary: #1d4ed8; /* blue-700 */
            --theme-accent-bg: #eff6ff; /* blue-50 */
            --theme-accent-text: #1e3a8a; /* blue-900 */
            --theme-progress-from: #2563eb; /* blue-600 */
            --theme-progress-to: #1d4ed8; /* blue-700 */
            --theme-input-border: #93c5fd; /* blue-300 */
            --theme-input-focus-ring: #60a5fa; /* blue-400 */
            --theme-orange-text: #ea580c; /* orange-600 */ /* New variable for orange text */
            --theme-orange-dark-text: #fdba74; /* orange-300 */ /* New variable for dark mode orange text */
            --theme-blue-motivation-icon: #2563eb; /* blue-600 for motivation icon */
        }

        .dark {
            /* Dark mode colors (Blue theme) */
            --theme-primary: #93c5fd; /* blue-300 */
            --theme-secondary: #60a5fa; /* blue-400 */
            --theme-accent-bg: #1e3a8a; /* blue-900 */
            --theme-accent-text: #eff6ff; /* blue-50 */
            --theme-progress-from: #93c5fd; /* blue-300 */
            --theme-progress-to: #60a5fa; /* blue-400 */
            --theme-input-border: #2563eb; /* blue-600 */
            --theme-input-focus-ring: #3b82f6; /* blue-500 */
            --theme-orange-text: #fdba74; /* orange-300 */ /* New variable for orange text in dark mode */
            --theme-orange-dark-text: #ea580c; /* orange-600 */ /* New variable for dark mode orange text */
            --theme-blue-motivation-icon: #93c5fd; /* blue-300 for motivation icon in dark mode */
        }

        /* Custom scrollbar for modals */
        .modal-scrollable-content::-webkit-scrollbar {
            width: 8px;
        }

        .modal-scrollable-content::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }

        .modal-scrollable-content::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 10px;
        }

        .modal-scrollable-content::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        /* Dark mode scrollbar */
        .dark .modal-scrollable-content::-webkit-scrollbar-track {
            background: #333;
        }

        .dark .modal-scrollable-content::-webkit-scrollbar-thumb {
            background: #666;
        }

        .dark .modal-scrollable-content::-webkit-scrollbar-thumb:hover {
            background: #999;
        }

        /* Custom scrollbar for dropdown (if content overflows) */
        .dropdown-scrollable::-webkit-scrollbar {
            width: 8px;
        }
        .dropdown-scrollable::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }
        .dropdown-scrollable::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 10px;
        }
        .dropdown-scrollable::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
        .dark .dropdown-scrollable::-webkit-scrollbar-track {
            background: #333;
        }
        .dark .dropdown-scrollable::-webkit-scrollbar-thumb {
            background: #666;
        }
        .dark .dropdown-scrollable::-webkit-scrollbar-thumb:hover {
            background: #999;
        }

        /* Main font for the entire body */
        body {
            font-family: 'Vazirmatn FD', sans-serif; /* Font changed to Vazirmatn FD */
            direction: rtl; /* Ensure RTL direction for the entire body */
            -webkit-user-select: none; /* Safari */
            -moz-user-select: none;    /* Firefox */
            -ms-user-select: none;     /* Internet Explorer/Edge */
            user-select: none;         /* Standard */
            display: flex; /* Added for new header layout */
            flex-direction: column; /* Added for new header layout */
            align-items: center; /* Added for new header layout */
            min-height: 100vh; /* Added for new header layout */
        }

        /* Allow selection for inputs and textareas */
        input,
        textarea {
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
            user-select: text;
        }

        /* Force Vazirmatn to use Farsi numbers for all numbers */
        body,
        input[type="number"],
        input[type="text"],
        select {
            font-feature-settings: "ss02",
                "locl"; /* Stylistic set 2 and local forms for Vazirmatn */
            font-variant-numeric: traditional; /* Use traditional numeric forms */
            unicode-bidi: plaintext; /* Helps with mixed directionality in inputs */
        }

        /* Modal box styles */
        .modal-box {
            height: 75vh; /* Dynamic height: 3/4 of viewport height */
            max-height: 80vh; /* Max height for modal content, more dynamic */
        }

        /* Inner scrollable content area */
        .modal-scrollable-content {
            flex-grow: 1; /* Allows content to take available space */
            overflow-y: auto; /* Enable vertical scrolling */
            padding-left: 1rem; /* Adjust padding for scrollbar */
            padding-right: 1rem;
        }

        /* Point gain animation */
        .points-gain-feedback {
            position: absolute;
            font-weight: bold;
            color: #22C55E; /* Green color, remains constant */
            animation: fadeOutUp 1.5s forwards;
            pointer-events: none; /* Ensure it doesn't block clicks */
            z-index: 20;
        }

        @keyframes fadeOutUp {
            0% {
                opacity: 1;
                transform: translateY(0);
            }
            100% {
                opacity: 0;
                transform: translateY(-50px);
            }
        }

        /* Confetti effect */
        .confetti-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
            z-index: 9999;
        }

        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: #f0f; /* Default color */
            animation: confetti-fall 3s ease-out forwards;
            opacity: 0;
        }

        /* Corrected confetti-fall keyframes - removed duplicate 100% */
        @keyframes confetti-fall {
            0% {
                opacity: 0;
                transform: translateY(-100px) rotate(0deg);
            }
            10% {
                opacity: 1;
            }
            100% {
                opacity: 0;
                transform: translateY(100vh) rotate(720deg);
            }
        }

        /* Dynamic styles for inputs and selectors */
        input[type="text"], input[type="number"], select {
            border-color: var(--theme-input-border);
        }
        input[type="text"]:focus, input[type="number"]:focus, select:focus {
            outline: none;
            box-shadow: 0 0 0 2px var(--theme-input-focus-ring);
        }

        /* Dynamic styles for inputs and selectors in dark mode */
        .dark input[type="text"], .dark input[type="number"], .dark select {
            border-color: var(--theme-input-border); /* Use dark mode specific border color */
        }
        .dark input[type="text"]:focus, .dark input[type="number"]:focus, .dark select:focus {
            box-shadow: 0 0 0 2px var(--theme-input-focus-ring); /* Use dark mode specific focus ring color */
        }
        .clickable-item {
            cursor: pointer;
            transition: background-color 0.2s ease-in-out;
        }
        .clickable-item:hover {
            background-color: rgba(0, 0, 0, 0.05); /* Light hover for light mode */
        }
        .dark .clickable-item:hover {
            background-color: rgba(255, 255, 255, 0.05); /* Dark hover for dark mode */
        }

        /* Style for task title to wrap, not scroll */
        .task-name-wrapper {
            white-space: normal; /* Allow text wrapping */
            word-break: break-word; /* Break long words */
            flex-grow: 1; /* Allow it to take available space */
            min-width: 0; /* Allow it to shrink smaller than its content */
        }

        /* New: Justify text for note importance tasks */
        .task-name-wrapper.text-align-justify-rtl {
            text-align: justify;
        }

        .line-through .task-name {
            text-decoration: line-through;
        }

        /* Task item animations */
        .task-item {
            transition: all 0.3s ease-in-out; /* Smooth transitions for all changes */
        }
        .task-item.is-hidden-original {
            opacity: 0;
            /* No transform here, just opacity */
        }
        /* Animation for newly added tasks */
        .task-item.new-task-animation {
            opacity: 0;
            transform: translateY(20px);
        }
        .task-item.new-task-animation.animate-in {
            opacity: 1;
            transform: translateY(0);
        }

        /* Styles for reordering mode */
        .task-item.reordering-disabled {
            opacity: 0.5;
            pointer-events: none;
        }
        .task-item.reordering-active {
            /* Removed box-shadow for cleaner look */
        }

        /* Highlight animation for focus */
        .task-item.highlight {
            animation: highlight-pulse 1.5s ease-out; /* Pulsing highlight */
        }

        @keyframes highlight-pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(99, 102, 241, 0.4); /* Indigo glow */
                transform: scale(1);
            }
            50% {
                box-shadow: 0 0 0 8px rgba(0, 0, 0, 0); /* Fade out glow */
                transform: scale(1.02); /* Slight pop */
            }
            100% {
                box-shadow: 0 0 0 0 rgba(0, 0, 0, 0);
                transform: scale(1);
            }
        }


        /* Three-dot menu popup styles */
        .task-action-menu {
            position: absolute;
            background-color: white;
            border-radius: 0.5rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1); /* Keep shadow for menu for visibility */
            padding: 0.5rem;
            z-index: 50;
            min-width: 150px;
            transform-origin: top right;
            animation: scaleIn 0.15s ease-out forwards;
        }
        .dark .task-action-menu {
            background-color: #374151; /* Gray-700 */
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3); /* Keep shadow for menu for visibility */
        }
        .task-action-menu button {
            display: flex;
            align-items: center;
            width: 100%;
            padding: 0.75rem 1rem; /* Increased padding */
            border-radius: 0.375rem;
            text-align: right;
            font-size: 0.95rem; /* Slightly larger text */
            color: #374151; /* Gray-700 */
            transition: background-color 0.2s ease-in-out;
        }
        .dark .task-action-menu button {
            color: #d1d5db; /* Gray-300 */
        }
        .task-action-menu button:hover {
            background-color: #f3f4f6; /* Gray-100 */
        }
        .dark .task-action-menu button:hover {
            background-color: #4b5563; /* Gray-600 */
        }
        .task-action-menu button svg {
            margin-left: 0.75rem; /* ml-3 */
            font-size: 1.2rem; /* Larger icons */
        }

        @keyframes scaleIn {
            0% { transform: scale(0.95); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }

        /* Dynamic modal styles (edit/reorder) */
        .dynamic-modal {
            position: fixed;
            inset: 0;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1rem;
            z-index: 60; /* Higher than other modals */
            transition: opacity 0.3s ease-in-out;
            opacity: 0;
            pointer-events: none;
        }
        .dynamic-modal.show {
            opacity: 1;
            pointer-events: auto;
        }
        .dynamic-modal-content {
            background-color: white;
            border-radius: 0.5rem;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2); /* Keep shadow for modals for visibility */
            padding: 1.5rem;
            width: 100%;
            max-width: 400px; /* Kept for general modal content */
            transform: translateY(-20px);
            transition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out;
            opacity: 0;
            position: relative;
        }
        .dark .dynamic-modal-content {
            background-color: #374151; /* Gray-700 */
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3); /* Keep shadow for modals for visibility */
        }
        .dynamic-modal.show .dynamic-modal-content {
            transform: translateY(0);
            opacity: 1;
        }
        .dynamic-modal-content input, .dynamic-modal-content select {
            width: 100%;
            margin-bottom: 1rem;
        }
        .dynamic-modal-content button {
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            font-weight: bold;
            transition: transform 0.1s ease-in-out;
        }
        .dynamic-modal-content button:hover {
            transform: scale(1.02);
        }

        /* Mobile specific styles for the main container */
        @media (max-width: 639px) { /* Tailwind's 'sm' breakpoint is 640px */
            body {
                padding-left: 0 !important;
                padding-right: 0 !important;
                /* Removed padding-top and padding-bottom from body */
            }
            .container {
                border-radius: 0 !important; /* Override rounded corners */
                box-shadow: none !important; /* Override shadow */
                padding-left: 0.5rem !important; /* Smaller padding on mobile */
                padding-right: 0.5rem !important;
                padding-top: 20px !important; /* Added 20px padding to container */
                padding-bottom: 20px !important; /* Added 20px padding to container */
            }
            /* Header adjustments for mobile */
            .header-mobile-flex {
                flex-direction: column;
                align-items: center;
                text-align: center;
            }
            .header-mobile-stats {
                flex-wrap: nowrap; /* Prevent wrapping on mobile */
                justify-content: center;
                gap: 0.5rem; /* Smaller gap for mobile stats */
                margin-top: 1rem;
                overflow-x: auto; /* Enable horizontal scroll */
                -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
                padding-bottom: 0.5rem; /* Add some padding for scrollbar if needed */
            }
            .header-mobile-stats > div {
                flex-shrink: 0; /* Prevent shrinking */
                min-width: fit-content; /* Ensure content fits */
                padding-left: 0.75rem; /* Adjust padding for items */
                padding-right: 0.75rem;
            }

            /* Fix for completed tasks section on mobile */
            #completedTasksSection {
                width: 100%; /* Ensure it takes full width */
                box-sizing: border-box; /* Include padding/border in width */
                padding-left: 0.5rem; /* Match container padding */
                padding-right: 0.5rem; /* Match container padding */
            }
            #completedTasksContainer {
                padding-left: 0; /* Remove specific padding from task-list-container */
                padding-right: 0; /* Remove specific padding from task-list-container */
            }
        }

        /* Update the three-dot menu button to match the move buttons */
        .three-dot-menu-btn {
            height: 28px; /* Match importance select height and move buttons */
            width: 28px; /* Ensure it's square */
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0; /* Remove default padding */
            border-radius: 9999px; /* Ensure fully rounded corners */
            /* Existing styles: bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 text-gray-800 dark:text-gray-100 transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-blue-400 */
        }
        .three-dot-menu-btn svg {
            height: 16px; /* Adjust icon size if needed, h-4 w-4 is 16px */
            width: 16px;
        }

        /* Styles for the new Achievements Modal */
        .achievement-item-card {
            background: linear-gradient(to bottom right, var(--theme-accent-bg), var(--theme-accent-bg)); /* Use accent background for base */
            border: 1px solid var(--theme-input-border);
            border-radius: 0.75rem; /* More rounded corners */
            padding: 1.5rem; /* More padding */
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05); /* Subtle shadow */
            transition: all 0.3s ease-in-out;
            cursor: pointer;
            min-height: 150px; /* Ensure a minimum height */
            max-height: 200px; /* Prevent excessive stretching */
            justify-content: center; /* Center content vertically */
        }
        .achievement-item-card:hover {
            transform: translateY(-5px) scale(1.02); /* Lift and grow on hover */
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.1); /* More prominent shadow on hover */
            background: linear-gradient(to bottom right, var(--theme-secondary), var(--theme-primary)); /* Gradient on hover */
            color: #fff; /* White text on hover */
        }
        .dark .achievement-item-card {
            background: linear-gradient(to bottom right, #374151, #1f2937); /* Darker gradient for dark mode */
            border-color: #4b5563;
        }
        .dark .achievement-item-card:hover {
            background: linear-gradient(to bottom right, var(--theme-secondary), var(--theme-primary)); /* Dark mode hover gradient */
            color: #fff;
        }

        /* Adjusted icon size for achievement cards to be responsive and consistent */
        .achievement-item-card .icon {
            font-size: 2.25rem; /* Reverted to 4xl (2.25rem) */
            margin-bottom: 0.5rem; /* Adjusted margin for smaller icon */
            color: var(--theme-primary); /* Icon color based on theme */
            transition: color 0.3s ease-in-out;
        }
        .achievement-item-card:hover .icon {
            color: #fff; /* White icon on hover */
        }

        /* Styles for unachieved achievements */
        .achievement-item-card.unachieved {
            opacity: 0.5; /* Faded appearance */
            filter: grayscale(100%); /* Grayscale effect */
            cursor: default; /* No pointer on hover for unachieved */
        }
        .achievement-item-card.unachieved:hover {
            transform: none; /* No hover transform */
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05); /* No prominent shadow on hover */
            background: linear-gradient(to bottom right, var(--theme-accent-bg), var(--theme-accent-bg)); /* No gradient on hover */
            color: inherit; /* Inherit text color */
        }
        .dark .achievement-item-card.unachieved:hover {
            background: linear-gradient(to bottom right, #374151, #1f2937);
        }
        .achievement-item-card.unachieved .icon {
            color: var(--theme-secondary); /* Use secondary color for faded icon */
        }
        .achievement-item-card.unachieved:hover .icon {
            color: var(--theme-secondary); /* Keep secondary color on hover */
        }
        .achievement-item-card.unachieved .name,
        .achievement-item-card.unachieved .description {
            color: var(--theme-secondary); /* Faded text color */
        }
        .achievement-item-card.unachieved:hover .name,
        .achievement-item-card.unachieved:hover .description {
            color: var(--theme-secondary); /* Keep faded text color on hover */
        }


        .achievement-item-card .name {
            font-size: 1.1rem; /* Slightly smaller default name size */
            font-weight: bold;
            margin-bottom: 0.5rem;
            color: var(--theme-accent-text);
            transition: color 0.3s ease-in-out;
        }
        .achievement-item-card:hover .name {
            color: #fff;
        }

        .achievement-item-card .description {
            font-size: 0.9rem;
            color: var(--theme-secondary);
            transition: color 0.3s ease-in-out;
            /* Removed description from here as it's now only in detail modal */
            display: none; /* Hide description in the main achievement card */
        }
        .achievement-item-card:hover .description {
            color: #e5e7eb; /* Lighter text on hover */
        }

        /* New Achievement Notification Modal Styles */
        #achievementNotificationModal {
            background-color: rgba(0, 0, 0, 0.6); /* Slightly darker overlay */
        }
        #achievementNotificationModalContent {
            background: linear-gradient(to bottom right, var(--theme-primary), var(--theme-secondary)); /* Minimal blue gradient */
            color: white;
            border-radius: 1rem; /* More rounded */
            padding: 1.5rem; /* Adjusted padding */
            padding-bottom: 2rem; /* Added padding for button */
            text-align: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4); /* Stronger shadow */
            animation: bounceIn 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards; /* Bouncy animation */
            width: 90%; /* Responsive width */
            max-width: 400px; /* Max width for the modal content itself */
            max-height: 90vh; /* Allow modal to take up to 90% of viewport height */
            overflow-y: auto; /* Enable scrolling if content exceeds max-height */
            position: relative; /* Keep relative for positioning children */
            overflow-x: hidden; /* Hide horizontal overflow */
        }
        .dark #achievementNotificationModalContent {
            background: linear-gradient(to bottom right, var(--theme-secondary), var(--theme-primary)); /* Darker blue gradient */
        }

        /* Adjusted icon size for achievement notification modal to be consistent with achievement cards */
        #achievementNotificationModalContent .icon {
            font-size: 4.5rem !important; /* Changed to 7xl (4.5rem) */
            margin-bottom: 0.3125rem; /* 5px from bottom */
            color: #ffeb3b; /* Bright yellow for icon */
            animation: pulse 1.5s infinite; /* Pulsing animation for icon */
            display: flex; /* Ensure flex properties for centering */
            align-items: center;
            justify-content: center;
        }

        #achievementNotificationModalContent .title {
            font-size: 1.5rem; /* Adjusted title size */
            font-weight: bold;
            margin-bottom: 0.5rem; /* Adjusted margin */
            text-shadow: 1px 1px 3px rgba(0,0,0,0.3);
        }

        #achievementNotificationModalContent .message {
            font-size: 1rem; /* Reverted message size to 1rem */
            margin-bottom: 1.5rem; /* Adjusted margin */
            line-height: 1.5;
        }

        #achievementNotificationModalContent .close-btn {
            background-color: rgba(255, 255, 255, 0.2); /* Semi-transparent white */
            color: white;
            padding: 0.75rem 2rem;
            border-radius: 9999px; /* Pill shape */
            font-weight: bold;
            transition: background-color 0.3s ease-in-out, transform 0.2s ease-in-out;
            border: 2px solid rgba(255, 255, 255, 0.5); /* White border */
        }
        #achievementNotificationModalContent .close-btn:hover {
            background-color: rgba(255, 255, 255, 0.3);
            transform: scale(1.05);
        }

        @keyframes bounceIn {
            0% { transform: scale(0.3); opacity: 0; }
            50% { transform: scale(1.1); opacity: 1; }
            70% { transform: scale(0.9); }
            100% { transform: scale(1); opacity: 1; }
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        /* Styles for Level/Achievement Details Spinners */
        .clickable-badge {
            display: inline-flex; /* Use inline-flex to allow badges to be next to each other */
            align-items: center;
            padding: 0.5rem 0.75rem; /* py-2 px-3 equivalent */
            border-radius: 9999px; /* rounded-full equivalent */
            background-color: #f9fafb; /* bg-gray-50 equivalent */
            border: 1px solid #e5e7eb; /* border border-gray-200 equivalent */
            color: #1f2937; /* text-gray-900 equivalent */
            font-size: 0.875rem; /* text-sm equivalent */
            font-weight: 500; /* font-medium equivalent */
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05); /* shadow-sm equivalent */

            /* RTL specific positioning and content flow */
            direction: rtl; /* Makes content flow from right to left */
            justify-content: flex-start; /* Aligns content to the right edge of the badge (because direction is rtl) */

            /* Dynamic width and no wrapping */
            flex-grow: 1; /* Allow badges to grow and fill available space */
            flex-shrink: 1; /* Allow badges to shrink if needed */
            flex-basis: auto; /* Let content determine initial size */
            min-width: fit-content; /* Ensure content determines min width */
            white-space: nowrap; /* Prevent text from wrapping */
            overflow: hidden; /* Hide overflowing content */
            text-overflow: ellipsis; /* Show ellipsis for clipped text */
        }

        .clickable-badge:hover {
            background-color: #e5e7eb; /* hover:bg-gray-200 equivalent */
            border-color: #9ca3af; /* hover:border-gray-400 equivalent */
        }

        .clickable-badge i {
            margin-right: 0.5rem; /* Add space between icon (right) and text (left) */
            margin-left: 0; /* Ensure no conflicting margin-left */
            font-size: 1rem; /* Adjust icon size if needed */
        }

        /* Specific colors for level/achievement badges */
        .level-badge {
            background-color: #bfdbfe; /* blue-200 */
            color: #1e40af; /* blue-800 */
        }
        .dark .level-badge {
            background-color: #1e3a8a; /* blue-900 */
            color: #93c5fd; /* blue-300 */
        }
        .level-badge:hover {
            background-color: #93c5fd; /* blue-300 */
            color: #1e40af; /* blue-800 */
        }
        .dark .level-badge:hover {
            background-color: #1d4ed8; /* blue-700 */
            color: #bfdbfe; /* blue-200 */
        }

        .achievement-badge {
            background-color: #d1fae5; /* green-100 */
            color: #065f46; /* green-800 */
        }
        .dark .achievement-badge {
            background-color: #064e3b; /* green-900 */
            color: #a7f3d0; /* green-300 */
        }
        .achievement-badge:hover {
            background-color: #a7f3d0; /* green-300 */
            color: #065f46; /* green-800 */
        }
        .dark .achievement-badge:hover {
            background-color: #047857; /* green-700 */
            color: #d1fae5; /* green-100 */
        }

        .details-container {
            margin-top: 10px;
            padding: 10px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            background-color: #f9f9f9;
            animation: fadeIn 0.3s ease-out;
        }
        .dark .details-container {
            background-color: #4b5563; /* Gray-700 */
            border-color: #6b7280; /* Gray-600 */
        }
        .text-justify {
            text-align: justify;
            text-justify: inter-word;
        }
        /* Adjusted semi-formal-text margin-bottom for tighter spacing */
        .semi-formal-text {
            font-family: 'Vazirmatn FD', sans-serif; /* Already default, but good to be explicit */
            font-size: 0.95rem; /* Slightly smaller for minimal feel */
            line-height: 1.6;
            color: #4a5568; /* Darker gray for semi-formal */
            padding: 0.5rem 0; /* Some vertical padding */
            text-align: justify; /* Ensure semi-formal text is justified */
            margin-bottom: 0.25rem; /* Adjusted for tighter spacing (mb-1) */
        }
        .dark .semi-formal-text {
            color: #cbd5e0; /* Lighter gray for dark mode */
        }
        /* Specific styles for help modal headings */
        .help-heading-blue {
            color: var(--theme-primary); /* blue-600 */
        }
        .dark .help-heading-blue {
            color: var(--theme-primary); /* blue-300 */
        }
        .help-heading-green {
            color: var(--theme-primary); /* green-600 changed to blue */
        }
        .dark .help-heading-green {
            color: var(--theme-primary); /* green-300 changed to blue */
        }
        .help-heading-orange { /* Changed from purple to orange */
            color: var(--theme-primary); /* Use new orange variable, changed to blue */
        }
        .dark .help-heading-orange { /* Changed from purple to orange */
            color: var(--theme-primary); /* Use new orange variable for dark mode, changed to blue */
        }
        .help-heading-red {
            color: var(--theme-primary); /* red-600 changed to blue */
        }
        .dark .help-heading-red {
            color: var(--theme-primary); /* red-300 changed to blue */
        }

        /* Styles for About Us links */
        #aboutModalBody a {
            color: var(--theme-primary); /* Blue color for links */
            transition: color 0.2s ease-in-out;
        }
        #aboutModalBody a:hover {
            color: var(--theme-secondary); /* Darker blue on hover */
        }
        .dark #aboutModalBody a {
            color: var(--theme-primary); /* Light blue for links in dark mode */
        }
        .dark #aboutModalBody a:hover {
            color: var(--theme-secondary); /* Darker light blue on hover */
        }

        /* Motivation Section Styles */
        #motivationContainer {
            min-height: 3rem; /* Ensure enough height for the text */
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative; /* For absolute positioning of text */
            overflow: hidden; /* Hide overflowing text during transition */
        }

        /* New Motivation Animation */
        @keyframes motivation-slide-out {
            0% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-20px); } /* Slide up and fade out */
        }

        @keyframes motivation-slide-in {
            0% { opacity: 0; transform: translateY(20px); } /* Start from below and fade in */
            100% { opacity: 1; transform: translateY(0); }
        }

        #motivationText {
            position: absolute;
            width: 90%;
            max-width: 600px;
            text-align: center;
            opacity: 0; /* Default hidden */
            transform: translateY(0); /* Default position */
        }

        #motivationText.animate-out {
            animation: motivation-slide-out 0.6s ease-out forwards;
        }

        #motivationText.animate-in {
            animation: motivation-slide-in 0.6s ease-out forwards;
        }


        /* Dropdown Corners Styling */
        #pointsDropdownToggle {
            border-radius: 0.5rem; /* Tailwind rounded-lg */
            transition: border-bottom-left-radius 0.3s ease-in-out, border-bottom-right-radius 0.3s ease-in-out;
        }
        #pointsDropdownToggle.is-open {
            border-bottom-left-radius: 0;
            border-bottom-right-radius: 0;
        }

        #pointsDropdownContent {
            border-radius: 0.5rem; /* Tailwind rounded-lg */
            transition: all 0.3s ease-in-out; /* Smooth transition for opening/closing */
        }

        /* When dropdown is open, adjust its top corners */
        #pointsDropdownContent.is-open {
            border-top-left-radius: 0;
            border-top-right-radius: 0;
            border-bottom-left-radius: 0.5rem; /* Keep bottom corners rounded */
            border-bottom-right-radius: 0.5rem; /* Keep bottom corners rounded */
            overflow: hidden; /* Crucial for clipping content to rounded corners */
        }

        /* Adjust inner panels when dropdown is open */
        #pointsDropdownContent.is-open > div { /* This targets the flex container inside dropdown */
            border-radius: 0; /* Remove rounding from container */
        }

        /* Target the first child of the inner flex container (level panel) */
        #pointsDropdownContent.is-open > div > div:first-child {
            border-top-left-radius: 0.5rem;
            border-top-right-radius: 0.5rem;
            border-bottom-left-radius: 0;
            border-bottom-right-radius: 0;
        }

        /* Target the last child of the inner flex container (streak panel) */
        #pointsDropdownContent.is-open > div > div:last-child {
            border-top-left-radius: 0;
            border-top-right-radius: 0;
            border-bottom-left-radius: 0.5rem;
            border-bottom-right-radius: 0.5rem;
        }
    </style>
</head>
<body class="px-0 py-0 sm:p-4 flex items-center justify-center min-h-screen bg-gray-100 dark:bg-gray-900 text-gray-800 dark:text-gray-100">
    <div class="container bg-white dark:bg-gray-800 rounded-none sm:rounded-xl p-0 sm:p-6 md:p-8 w-full max-w-4xl relative sm:h-auto">
        <header class="relative p-4 flex items-center bg-transparent text-gray-800 dark:text-gray-100">
            <button id="menuBtn" class="p-1.5 rounded-full bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 transition duration-300 ease-in-out focus:outline-none focus:ring-2 focus:ring-blue-400" aria-label="باز کردن منو">
                <svg class="h-5 w-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 5v.01M12 12v.01M12 19v.01M12 6a1 1 0 100-2 1 1 0 000 2zm0 7a1 1 0 100-2 1 1 0 000 2zm0 7a1 1 0 100-2 1 1 0 000 2z"></path>
                </svg>
            </button>

            <h1 class="text-3xl font-bold text-gray-800 dark:text-gray-100 mr-3">زای تسک</h1>

            <div id="menuDropdown" class="absolute right-4 top-full mt-2 w-48 bg-white dark:bg-gray-700 rounded-md shadow-lg py-1 hidden z-20">
                <a href="#" id="profileMenuItem" class="block px-4 py-2 text-sm text-gray-700 dark:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-600 transition duration-200 ease-in-out flex items-center">
                    <i class="fa-solid fa-user ml-2"></i> پروفایل
                </a>
                <a href="#" id="achievementsMenuItem" class="block px-4 py-2 text-sm text-gray-700 dark:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-600 transition duration-200 ease-in-out flex items-center">
                    <i class="fa-solid fa-trophy ml-2"></i> دستاوردها
                </a>
                <a href="#" id="helpMenuItem" class="block px-4 py-2 text-sm text-gray-700 dark:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-600 transition duration-200 ease-in-out flex items-center">
                    <i class="fa-solid fa-circle-question ml-2"></i> راهنما
                </a>
                <a href="#" id="aboutMenuItem" class="block px-4 py-2 text-sm text-gray-700 dark:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-600 transition duration-200 ease-in-out flex items-center">
                    <i class="fa-solid fa-circle-info ml-2"></i> درباره ما
                </a>
                <a href="#" id="backupMenuItem" class="block px-4 py-2 text-sm text-gray-700 dark:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-600 transition duration-300 ease-in-out flex items-center">
                    <i class="fa-solid fa-download ml-2"></i> پشتیبان‌گیری
                </a>
                <a href="#" id="updateAppMenuItem" class="block px-4 py-2 text-sm text-gray-700 dark:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-600 transition duration-200 ease-in-out flex items-center">
                    <i class="fa-solid fa-sync-alt ml-2"></i> بروزرسانی برنامه
                </a>
                <a href="#" id="donateMenuItem" class="block px-4 py-2 text-sm text-gray-700 dark:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-600 transition duration-200 ease-in-out flex items-center">
                    <i class="fa-solid fa-hand-holding-dollar ml-2"></i> حمایت مالی
                </a>
                <a href="#" id="shareAppLink" class="block px-4 py-2 text-sm text-gray-700 dark:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-600 transition duration-200 ease-in-out flex items-center">
                    <i class="fas fa-share-alt ml-2"></i>اشتراک‌گذاری
                </a>
                <a href="#" id="installAppLink" class="block px-4 py-2 text-sm text-gray-700 dark:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-600 transition duration-200 ease-in-out flex items-center">
                    <i class="fas fa-download ml-2"></i>نصب برنامه
                </a>
                <a href="#" id="resetMenuItem" class="block px-4 py-2 text-sm text-red-700 dark:text-red-200 hover:bg-red-100 dark:hover:bg-red-600 transition duration-200 ease-in-out flex items-center">
                    <i class="fa-solid fa-arrows-rotate ml-2"></i> بازنشانی داده‌ها
                </a>
            </div>
        </header>

        <div class="relative w-full mt-1"> <div id="pointsDropdownToggle" class="flex items-center justify-between w-full py-3 px-4 bg-blue-500 dark:bg-blue-700 text-white cursor-pointer transition-all duration-200 ease-in-out hover:bg-blue-600 dark:hover:bg-blue-800 rounded-lg">
                <div class="flex items-center">
                    <i class="fa-solid fa-coins text-xl ml-2"></i>
                    <span class="text-lg font-semibold">پوینت: <span id="zPoint">0</span></span>
                </div>
                <i id="dropdownIndicator" class="fa-solid fa-chevron-down transition-transform duration-200"></i>
            </div>

            <div id="pointsDropdownContent" class="absolute top-full left-0 right-0 w-full bg-white dark:bg-gray-800 shadow-lg py-2 hidden z-10 transition-all duration-200 ease-in-out origin-top opacity-0 scale-y-95 transform dropdown-scrollable">
                <div class="flex flex-col gap-2 p-2">
                    <div class="flex items-center gap-2 theme-blue-bg theme-blue-text px-4 py-2 rounded-lg">
                        <div class="flex items-center">
                            <i id="levelIcon" class="fa-solid fa-star text-xl ml-2"></i>
                            <span class="text-base font-semibold">سطح:</span>
                        </div>
                        <span id="level" class="text-base font-semibold">1</span>
                    </div>
                    <div class="flex items-center gap-2 theme-purple-bg theme-purple-text px-4 py-2 rounded-lg">
                        <div class="flex items-center">
                            <i class="fa-solid fa-fire text-xl ml-2"></i>
                            <span class="text-base font-semibold">زنجیره:</span>
                        </div>
                        <span id="dailyStreak" class="text-base font-semibold">0 روز</span>
                    </div>
                </div>
            </div>
        </div>
        <div class="mb-6 px-2 md:px-0 mt-5"> <h2 class="text-lg sm:text-xl font-semibold text-gray-700 dark:text-gray-300 mb-2">پیشرفت شما به سطح بعدی:</h2>
            <div class="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-4">
                <div id="progressBar" class="h-4 rounded-full transition-all duration-500 ease-out" style="width: 0%;"></div>
            </div>
            <p id="progressText" class="text-sm text-gray-500 dark:text-gray-400 mt-1 text-center">0%</p>
        </div>

        <div class="mb-8 p-4 rounded-lg bg-gray-100 dark:bg-gray-900 text-gray-800 dark:text-gray-100 relative overflow-hidden">
            <h2 class="text-xl sm:text-2xl font-semibold mb-1 flex items-center justify-center">
                <i class="fa-solid fa-lightbulb ml-2" style="color: var(--theme-blue-motivation-icon);"></i>
                تلنگر
            </h2>
            <div id="motivationContainer" class="text-center text-lg sm:text-xl font-medium flex items-center justify-center">
                <span id="motivationText"></span>
            </div>
        </div>

        <div class="mb-8 p-4 rounded-lg bg-gray-100 dark:bg-gray-900" id="addTaskSection">
            <h2 class="text-xl sm:text-2xl font-semibold mb-4 text-gray-900 dark:text-gray-50" id="addTaskTitle">افزودن وظیفه جدید</h2>
            <div class="flex flex-col md:flex-row gap-4 items-stretch md:items-center">
                <input type="text" id="taskInput" placeholder="نام وظیفه را وارد کنید..." maxlength="30"
                       class="flex-grow p-3 border rounded-lg text-base sm:text-lg text-gray-700 dark:text-gray-100 placeholder-gray-400 dark:placeholder-gray-500 bg-white dark:bg-gray-700 h-12 text-right">
                <select id="importanceSelect"
                        class="p-3 border rounded-lg text-base sm:text-lg text-gray-700 dark:text-gray-100 bg-white dark:bg-gray-700 appearance-none h-12 w-full md:w-40 text-right">
                    <option value="important">مهم</option>
                    <option value="normal" selected>عادی</option>
                    <option value="custom">سفارشی</option>
                    <option value="note">یادداشت</option>
                </select>
                <input type="text" id="customPointsInput" placeholder="پوینت سفارشی (حداکثر ۲۰)" inputmode="numeric"
                       class="p-3 border rounded-lg text-base sm:text-lg text-gray-700 dark:text-gray-100 placeholder-gray-400 dark:placeholder-gray-500 bg-white dark:bg-gray-700 h-12 w-full md:w-32 hidden text-right">
                <button id="addTaskBtn"
                        class="text-white font-bold py-3 px-6 rounded-lg transition duration-300 ease-in-out transform hover:scale-105 text-lg w-full md:w-auto">
                    افزودن وظیفه
                </button>
            </div>
        </div>

        <div class="mb-6 px-2 md:px-0">
            <div class="flex flex-col sm:flex-row items-center justify-between mb-2">
                <h2 class="text-xl sm:text-2xl font-semibold text-gray-800 dark:text-gray-100 mb-2 sm:mb-0">وظایف فعال</h2>
                <div id="activeTasksPagination" class="flex items-center space-x-2 space-x-reverse hidden">
                </div>
            </div>
            <div id="activeTaskList" class="task-list-container"> </div>
        </div>

        <div class="mt-8 px-2 md:px-0">
            <button id="toggleCompletedTasksBtn" class="w-full bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 text-gray-800 dark:text-gray-100 font-bold py-3 px-6 rounded-lg transition duration-300 ease-in-out flex items-center justify-between focus:outline-none focus:ring-2 focus:ring-blue-400">
                <span>وظایف تکمیل شده</span>
                <svg id="toggleIcon" class="h-5 w-5 transform transition-transform duration-300" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
            </button>
            <div id="completedTasksSection" class="hidden mt-4">
                <div class="flex flex-col sm:flex-row items-center justify-between mb-1 mt-1">
                    <h2 class="text-xl sm:text-2xl font-semibold text-gray-800 dark:text-gray-100 mb-2 sm:mb-0"></h2>
                    <div id="completedTasksPagination" class="flex items-center space-x-2 space-x-reverse hidden">
                    </div>
                </div>
                <div id="completedTasksContainer" class="task-list-container"> </div>
            </div>
        </div>
    </div>

    <div id="reorderBar" class="fixed top-0 left-0 right-0 bg-blue-600 text-white p-3 flex items-center justify-between z-50 transition-all duration-300 opacity-0 pointer-events-none">
        <span class="text-lg font-bold">تغییر چیدمان</span>
        <button id="finishReorderBtn" class="bg-white text-blue-600 px-4 py-1 rounded-full text-sm font-semibold hover:bg-gray-100 transition-colors">
            پایان
        </button>
    </div>

    <div id="welcomeModal" class="fixed inset-0 bg-black bg-opacity-50 dark:bg-opacity-75 flex items-center justify-center p-4 hidden z-50">
        <div class="bg-white dark:bg-gray-800 rounded-lg p-6 w-full max-w-sm relative text-gray-800 dark:text-gray-100 transition-transform duration-300 transform scale-95 opacity-0" id="welcomeModalContent">
            <h3 class="text-xl sm:text-2xl font-bold mb-4 border-b pb-2 border-gray-200 dark:border-gray-700 text-center">به زای تسک خوش آمدید!</h3>
            <p class="mb-4 text-center text-gray-700 dark:text-gray-300">لطفاً نام خود را وارد کنید تا شروع کنیم:</p>
            <input type="text" id="userNameInput" placeholder="نام شما..." maxlength="15"
                   class="w-full p-3 border border-blue-300 dark:border-blue-600 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-400 dark:focus:ring-blue-300 text-base sm:text-lg text-gray-700 dark:text-gray-100 placeholder-gray-400 dark:placeholder-500 bg-white dark:bg-gray-700 mb-4 text-right">
            <button id="startBtn"
                    class="w-full bg-blue-600 hover:bg-blue-700 dark:bg-blue-700 dark:hover:bg-blue-800 text-white font-bold py-3 px-6 rounded-lg transition duration-300 ease-in-out transform hover:scale-105 text-lg">
                شروع کنید!
            </button>
        </div>
    </div>

    <div id="profileModal" class="fixed inset-0 bg-black bg-opacity-50 dark:bg-opacity-75 flex items-center justify-center p-4 hidden z-50">
        <div class="bg-white dark:bg-gray-800 rounded-lg p-6 w-full max-w-md relative text-gray-800 dark:text-gray-100 flex flex-col modal-box transition-transform duration-300 transform scale-95 opacity-0" id="profileModalContent">
            <h3 class="text-xl sm:text-2xl font-bold mb-4 border-b pb-2 border-gray-200 dark:border-gray-700">پروفایل کاربری</h3>
            <div id="profileModalBody" class="modal-scrollable-content text-justify text-sm leading-relaxed">
            </div>
            <button id="closeProfileModalBtn" class="absolute top-3 left-3 p-2 rounded-full hover:bg-gray-100 dark:hover:bg-gray-700 text-gray-500 dark:text-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-400">
                <svg class="h-6 w-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
        </div>
    </div>

    <div id="achievementsModal" class="fixed inset-0 bg-black bg-opacity-50 dark:bg-opacity-75 flex items-center justify-center p-4 hidden z-50">
        <div class="bg-white dark:bg-gray-800 rounded-lg p-6 w-full max-w-2xl relative text-gray-800 dark:text-gray-100 flex flex-col modal-box transition-transform duration-300 transform scale-95 opacity-0" id="achievementsModalContent">
            <h3 class="text-xl sm:text-2xl font-bold mb-4 border-b pb-2 border-gray-200 dark:border-gray-700">دستاوردها</h3>
            <div id="achievementsModalBody" class="modal-scrollable-content text-justify text-sm leading-relaxed grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
            </div>
            <button id="closeAchievementsModalBtn" class="absolute top-3 left-3 p-2 rounded-full hover:bg-gray-100 dark:hover:bg-gray-700 text-gray-500 dark:text-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-400">
                <svg class="h-6 w-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
        </div>
    </div>

    <div id="achievementNotificationModal" class="fixed inset-0 bg-black bg-opacity-50 dark:bg-opacity-75 flex items-center justify-center p-4 hidden z-50">
        <div class="bg-white dark:bg-gray-800 rounded-lg p-6 w-full max-w-sm relative text-gray-800 dark:text-gray-100 transition-transform duration-300 transform scale-95 opacity-0" id="achievementNotificationModalContent">
            <i id="achievementNotificationIcon" class="icon"></i>
            <h3 id="achievementNotificationTitle" class="title"></h3>
            <p id="achievementNotificationMessage" class="message"></p>
            <button id="closeAchievementNotificationModalBtn" class="close-btn">
                بستن
            </button>
        </div>
    </div>

    <div id="helpModal" class="fixed inset-0 bg-black bg-opacity-50 dark:bg-opacity-75 flex items-center justify-center p-4 hidden z-50">
        <div class="bg-white dark:bg-gray-800 rounded-lg p-6 w-full max-w-md relative text-gray-800 dark:text-gray-100 flex flex-col modal-box transition-transform duration-300 transform scale-95 opacity-0" id="helpModalContent">
            <h3 class="text-xl sm:text-2xl font-bold mb-4 border-b pb-2 border-gray-200 dark:border-gray-700">راهنما</h3>
            <div id="helpModalBody" class="modal-scrollable-content text-justify text-sm leading-relaxed">
            </div>
            <button id="closeHelpModalBtn" class="absolute top-3 left-3 p-2 rounded-full hover:bg-gray-100 dark:hover:bg-gray-700 text-gray-500 dark:text-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-400">
                <svg class="h-6 w-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
        </div>
    </div>

    <div id="aboutModal" class="fixed inset-0 bg-black bg-opacity-50 dark:bg-opacity-75 flex items-center justify-center p-4 hidden z-50">
        <div class="bg-white dark:bg-gray-800 rounded-lg p-6 w-full max-w-md relative text-gray-800 dark:text-gray-100 flex flex-col modal-box transition-transform duration-300 transform scale-95 opacity-0" id="aboutModalContent">
            <h3 class="text-xl sm:text-2xl font-bold mb-4 border-b pb-2 border-gray-200 dark:border-gray-700">درباره ما</h3>
            <div id="aboutModalBody" class="modal-scrollable-content text-justify text-sm leading-relaxed">
                <p class="mb-3 text-justify">این برنامه به منظور مدیریت وظایف و افزایش انگیزه طراحی شده است.</p>
                <p class="mb-3 text-justify">این پروژه به صورت اختصاصی توسط <strong class="text-gray-600 dark:text-gray-300"><a href="https://amuleo.ir" target="_blank" rel="noopener noreferrer">سایت عمو لئو</a></strong> طراحی شده است. این نسخه، اولین و آخرین نسخه از این پروژه است.</p>
                <div class="semi-formal-text text-justify mt-4 mb-4">
                    <p>برای ساخت این برنامه، 8 روز از مهم‌ترین روزهای عمرم صرف شد. روزهایی که امتحان داشتم، اما ۲۴ ساعت تمرکزم روی این پروژه بود و روزی ۱۶ ساعت، معادل 16 روز کاری روی این پروژه کار کردم. این پروژه بیش از ۲۰۰ یا ۳۰۰ بار دیباگ شده تا متناسب با هر صفحه نمایشی واکنش‌گرا باشد. برای همین، این پروژه پایان و خداحافظی من از دنیای برنامه‌نویسی است و دیگر این سایت آپدیت نمی‌شود.</p>
                </div>
                <p class="mb-3 text-justify">تمامی حقوق متعلق به <strong class="text-gray-600 dark:text-gray-300"><a href="https://amuleo.ir" target="_blank" rel="noopener noreferrer">عمو لئو</a></strong> است.</p>
                <p class="mb-3 text-justify">تاریخ: 9 خرداد ۱۴۰۴</p>
            </div>
            <button id="closeAboutModalBtn" class="absolute top-3 left-3 p-2 rounded-full hover:bg-gray-100 dark:hover:bg-gray-700 text-gray-500 dark:text-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-400">
                <svg class="h-6 w-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
        </div>
    </div>

    <div id="backupModal" class="fixed inset-0 bg-black bg-opacity-50 dark:bg-opacity-75 flex items-center justify-center p-4 hidden z-50">
        <div class="bg-white dark:bg-gray-800 rounded-lg p-6 w-full max-w-md relative text-gray-800 dark:text-gray-100 flex flex-col modal-box transition-transform duration-300 transform scale-95 opacity-0" id="backupModalContent">
            <h3 class="text-xl sm:text-2xl font-bold mb-4 border-b pb-2 border-gray-200 dark:border-gray-700">پشتیبان‌گیری و بازیابی داده‌ها</h3>
            <div class="modal-scrollable-content flex flex-col gap-4 text-justify">
                <p class="text-sm text-gray-700 dark:text-gray-300">برای پشتیبان‌گیری، دکمه "ذخیره داده‌ها" را فشار دهید تا فایل پشتیبان دانلود شود. برای بازیابی، فایل پشتیبان را انتخاب کرده و "بارگذاری از فایل" را فشار دهید.</p>

                <button id="exportDataBtn" class="bg-blue-600 hover:bg-blue-700 dark:bg-blue-700 dark:hover:bg-blue-800 text-white font-bold py-2 px-4 rounded-lg transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-blue-400">
                    ذخیره داده‌ها
                </button>

                <div class="flex items-center gap-2 mt-2">
                    <label for="importFileInput" class="bg-blue-600 hover:bg-blue-700 dark:bg-blue-700 dark:hover:bg-blue-800 text-white font-bold py-2 px-4 rounded-lg transition duration-300 ease-in-out cursor-pointer focus:outline-none focus:ring-2 focus:ring-blue-400">
                        انتخاب فایل
                    </label>
                    <span id="selectedFileName" class="text-sm text-gray-600 dark:text-gray-300 truncate max-w-[calc(100%-120px)]">فایلی انتخاب نشده است.</span>
                    <input type="file" id="importFileInput" accept=".json" class="hidden">
                </div>

                <button id="importDataBtn" class="bg-green-600 hover:bg-green-700 dark:bg-green-700 dark:hover:bg-green-800 text-white font-bold py-2 px-4 rounded-lg transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-green-400">
                    بارگذاری از فایل
                </button>
            </div>
            <button id="closeBackupModalBtn" class="absolute top-3 left-3 p-2 rounded-full hover:bg-gray-100 dark:hover:bg-gray-700 text-gray-500 dark:text-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-400">
                <svg class="h-6 w-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
        </div>
    </div>

    <div id="resetConfirmModal" class="fixed inset-0 bg-black bg-opacity-50 dark:bg-opacity-75 flex items-center justify-center p-4 hidden z-50">
        <div class="bg-white dark:bg-gray-800 rounded-lg p-6 w-full max-w-sm relative text-gray-800 dark:text-gray-100 transition-transform duration-300 transform scale-95 opacity-0" id="resetConfirmModalContent">
            <h3 class="text-xl sm:text-2xl font-bold mb-4 border-b pb-2 border-gray-200 dark:border-gray-700 text-center">تأیید بازنشانی داده‌ها</h3>
            <p class="mb-6 text-sm text-justify">آیا مطمئن هستید که می‌خواهید تمامی داده‌های برنامه را حذف کنید؟ این عمل غیرقابل بازگشت است.</p>
            <div class="flex justify-end space-x-4 space-x-reverse">
                <button id="confirmResetBtn" class="bg-red-600 hover:bg-red-700 dark:bg-red-700 dark:hover:bg-red-800 text-white font-bold py-2 px-4 rounded-lg transition duration-300 ease-in-out focus:outline-none focus:ring-2 focus:ring-red-400">
                    تأیید بازنشانی
                </button>
                <button id="cancelResetBtn" class="bg-gray-300 hover:bg-gray-400 dark:bg-gray-600 dark:hover:bg-gray-500 text-gray-800 dark:text-gray-100 font-bold py-2 px-4 rounded-lg transition duration-300 ease-in-out focus:outline-none focus:ring-2 focus:ring-gray-400">
                    لغو
                </button>
            </div>
            <button id="closeResetModalBtn" class="absolute top-3 left-3 p-2 rounded-full hover:bg-gray-100 dark:hover:bg-gray-700 text-gray-500 dark:text-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-400">
                <svg class="h-6 w-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
        </div>
    </div>

    <div id="updateConfirmModal" class="fixed inset-0 bg-black bg-opacity-50 dark:bg-opacity-75 flex items-center justify-center p-4 hidden z-50">
        <div class="bg-white dark:bg-gray-800 rounded-lg p-6 w-full max-w-sm relative text-gray-800 dark:text-gray-100 transition-transform duration-300 transform scale-95 opacity-0" id="updateConfirmModalContent">
            <h3 class="text-xl sm:text-2xl font-bold mb-4 border-b pb-2 border-gray-200 dark:border-gray-700 text-center">تأیید بروزرسانی برنامه</h3>
            <p class="mb-4 text-sm text-gray-700 dark:text-gray-300 text-justify">
                با تأیید بروزرسانی، برنامه زای تسک آخرین نسخه خود را از سرور دانلود می‌کند. این کار شامل:
            </p>
            <ul class="list-disc list-inside mb-6 text-sm text-gray-700 dark:text-gray-300 space-y-2 text-justify">
                <li><strong class="text-blue-600 dark:text-blue-300">پاکسازی کش برنامه:</strong> تمامی فایل‌های کش شده حذف می‌شوند تا از جدیدترین نسخه‌ها استفاده شود.</li>
                <li><strong class="text-green-600 dark:text-green-300">حفظ داده‌های شما:</strong> اطلاعات شخصی شما مانند وظایف، پوینت‌ها، سطح و دستاوردها <strong class="font-bold">حفظ خواهند شد</strong> و پاک نمی‌شوند.</li>
                <li><strong class="text-blue-600 dark:text-blue-300">بارگذاری مجدد صفحه:</strong> پس از اتمام فرآیند، صفحه به طور خودکار بارگذاری مجدد می‌شود تا تغییرات اعمال گردند.</li>
                <li><strong class="text-blue-600 dark:text-blue-300">توصیه:</strong> با وجود این ویژگی هایی که برای برنامه اتخاذ کرده‌ایم به شما توصیه می‌کنیم که پیش از تایید بروزرسانی از اطلاعات خود پشتیبان گیری کنید.</li>
            </ul>
            <p class="mb-6 text-sm text-gray-700 dark:text-gray-300 font-bold text-justify">
                آیا مایل به ادامه هستید؟
            </p>
            <div class="flex justify-end space-x-4 space-x-reverse">
                <button id="confirmUpdateBtn" class="bg-blue-600 hover:bg-blue-700 dark:bg-blue-700 dark:hover:bg-blue-800 text-white font-bold py-2 px-4 rounded-lg transition duration-300 ease-in-out focus:outline-none focus:ring-2 focus:ring-blue-400">
                    تأیید بروزرسانی
                </button>
                <button id="cancelUpdateBtn" class="bg-gray-300 hover:bg-gray-400 dark:bg-gray-600 dark:hover:bg-gray-500 text-gray-800 dark:text-gray-100 font-bold py-2 px-4 rounded-lg transition duration-300 ease-in-out focus:outline-none focus:ring-2 focus:ring-gray-400">
                    لغو
                </button>
            </div>
            <button id="closeUpdateModalBtn" class="absolute top-3 left-3 p-2 rounded-full hover:bg-gray-100 dark:hover:bg-gray-700 text-gray-500 dark:text-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-400">
                <svg class="h-6 w-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
        </div>
    </div>
    <div id="detailModal" class="fixed inset-0 bg-black bg-opacity-50 dark:bg-opacity-75 flex items-center justify-center p-4 hidden z-50">
        <div class="bg-white dark:bg-gray-800 rounded-lg p-6 w-full max-w-md relative text-gray-800 dark:text-gray-100 flex flex-col modal-box transition-transform duration-300 transform scale-95 opacity-0" id="detailModalContent">
            <h3 class="text-xl sm:text-2xl font-bold mb-4 border-b pb-2 border-gray-200 dark:border-gray-700" id="detailModalTitle"></h3>
            <div id="detailModalBody" class="modal-scrollable-content text-justify text-sm leading-relaxed">
            </div>
            <button id="closeDetailModalBtn" class="absolute top-3 left-3 p-2 rounded-full hover:bg-gray-100 dark:hover:bg-gray-700 text-gray-500 dark:text-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-400">
                <svg class="h-6 w-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
        </div>
    </div>

    <div id="editTaskModal" class="dynamic-modal hidden">
        <div class="dynamic-modal-content text-gray-800 dark:text-gray-100" id="editTaskModalContent">
            <h3 class="text-xl font-bold mb-4 border-b pb-2 border-gray-200 dark:border-gray-700">ویرایش وظیفه</h3>
            <input type="text" id="editTaskNameInput" placeholder="نام وظیفه را وارد کنید..." maxlength="30"
                   class="p-3 border rounded-lg text-base text-gray-700 dark:text-gray-100 placeholder-gray-400 dark:placeholder-gray-500 bg-white dark:bg-gray-700 text-right">
            <select id="editTaskImportanceSelect"
                    class="p-3 border rounded-lg text-base text-gray-700 dark:text-gray-100 bg-white dark:bg-gray-700 appearance-none text-right">
                <option value="important">مهم</option>
                <option value="normal">عادی</option>
                <option value="custom">سفارشی</option>
                <option value="note">یادداشت</option>
            </select>
            <input type="text" id="editTaskCustomPointsInput" placeholder="پوینت سفارشی (حداکثر ۲۰)" inputmode="numeric"
                   class="p-3 border rounded-lg text-base text-gray-700 dark:text-gray-100 placeholder-gray-400 dark:placeholder-gray-500 bg-white dark:bg-gray-700 hidden text-right">
            <div class="flex justify-end space-x-2 space-x-reverse">
                <button id="saveEditedTaskBtn" class="bg-green-600 hover:bg-green-700 dark:bg-green-700 dark:hover:bg-green-800 text-white">ذخیره</button>
                <button id="cancelEditTaskBtn" class="bg-gray-300 hover:bg-gray-400 dark:bg-gray-600 dark:hover:bg-gray-500 text-gray-800 dark:text-gray-100">لغو</button>
            </div>
        </div>
    </div>

    <div id="confettiContainer" class="confetti-container"></div>

    <div id="undoMessageBox" class="fixed bottom-4 left-1/2 -translate-x-1/2 p-4 rounded-lg text-white bg-gray-800 dark:bg-gray-700 z-50 transition-all duration-300 transform scale-0 opacity-0 flex items-center justify-between min-w-[200px] max-w-sm cursor-pointer hidden">
        <span id="undoMessageText" class="flex-grow mr-2"></span>
        <span id="undoCountdown" class="font-bold text-sm"></span>
    </div>

    <script>
        // Task data structure
        let tasks = [];
        let zPoint = 0; // Z-Point
        let level = 1; // Current level
        let dailyStreak = 0; // Daily streak counter
        let highestDailyStreak = 0; // Highest recorded streak
        let lastCompletionDate = null; // Date of last task completion
        let totalCustomTasksCompleted = 0; // Counter for custom tasks completed (still used for points, not achievements)
        let userName = null; // User's name
        let userCreationDate = null; // New: Date when user first set their name
        let unlockedAchievements = []; // Array to store IDs of unlocked achievements
        let achievementUnlockDates = {}; // New: Object to store unlock dates for achievements
        let hasPinnedTaskEver = false; // New: Tracks if a task has ever been pinned
        let currentMotivationIndex = 0; // New: Index for motivation quotes

        const pointsPerNormalTask = 10; // Points for normal tasks
        const pointsPerImportantTask = 25; // Points for important tasks
        const MAX_CUSTOM_POINTS = 20; // Max points for custom tasks
        const TASKS_PER_PAGE = 7; // Number of tasks displayed per page
        const DEFAULT_TASK_MAXLENGTH = 30; // Default max length for task input
        const NOTE_TASK_MAXLENGTH = 55; // Max length for note task input

        // Pagination status variables
        let activeCurrentPage = 1;
        let completedCurrentPage = 1;

        // Global state for reordering mode
        let isReorderingMode = false;
        let reorderingTaskId = null; // ID of the task currently being reordered

        // Points required to reach each level (Level 1 is zero points)
        const levelPointsThresholds = [
            { name: 'نوب', points: 0, icon: 'fa-solid fa-ghost', motivational: 'شروع هر سفر با گام اول است. شما در ابتدای مسیر هستید و آماده برای کشف توانایی‌هایتان!' }, /* Changed icon to fa-ghost */
            { name: 'مبتدی', points: 50, icon: 'fa-solid fa-seedling', motivational: 'شما با تلاش و پشتکار، بذر موفقیت را کاشته‌اید. به رشد خود ادامه دهید!' },
            { name: 'جنگجو', points: 120, icon: 'fa-solid fa-hand-fist', motivational: 'شما با هر چallenge، قوی‌تر و مصمم‌تر می‌شوید. روحیه جنگجویانه شما ستودنی است!' },
            { name: 'شوالیه', points: 220, icon: 'fa-solid fa-shield-halved', motivational: 'با هر وظیفه، زره‌ای از تجربه بر تن می‌کنید. شجاعت شما راهگشاست!' },
            { name: 'هیرو', points: 350, icon: 'fa-solid fa-mask', motivational: 'شما الهام‌بخش دیگران هستید. قدم‌هایتان ردپایی از موفقیت بر جای می‌گذارد!' },
            { level: 6, name: 'استاد', points: 500, icon: 'fa-solid fa-graduation-cap', motivational: 'دانش و مهارت شما در حال شکوفایی است. از هر تجربه درسی بیاموزید!' },
            { level: 7, name: 'فرمانده', points: 700, icon: 'fa-solid fa-star', motivational: 'اکنون می‌توانید رهبری کنید و مسیر را برای دیگران هموار سازید. قدرت در دستان شماست!' },
            { level: 8, name: 'سلطان', points: 950, icon: 'fa-solid fa-crown', motivational: 'شما بر قلمرو وظایف خود مسلط شده‌اید. با اقتدار به سوی اهداف بزرگتر گام بردارید!' },
            { level: 9, name: 'کار درست', points: 1250, icon: 'fa-solid fa-dragon', motivational: 'شما به قدرتی بی‌نظیر دست یافته‌اید. هیچ مانعی جلودار شما نخواهد بود!' },
            { level: 10, name: 'خفن', points: 1600, icon: 'fa-solid fa-fire-alt', motivational: 'شما به یک ستاره درخشان تبدیل شده‌اید. انرژی و خلاقیت شما بی‌حد و مرز است و هر کاری را به بهترین شکل ممکن انجام می‌دهید!' },
            { level: 11, name: 'جاودان', points: 2000, icon: 'fa-solid fa-infinity', motivational: 'پشتکار شما بی‌حد و مرز است. این مسیر، راهی برای جاودانگی دستاوردهای شماست!' },
            { level: 12, name: 'کیهان‌سالار', points: 2500, icon: 'fa-solid fa-bolt', motivational: 'شما با سرعتی باورنکردنی در حال پیشرفت هستید. انرژی شما جهان را به حرکت درمی‌آورد!' },
            { level: 13, name: 'کیهان‌نورد', points: 3000, icon: 'fa-solid fa-rocket', motivational: 'شما مرزها را درنوردیده‌اید و به سوی ناشناخته‌ها پرواز می‌کنید. آسمان حد شما نیست!' },
            { level: 14, name: 'بتمن', points: 3600, icon: 'fa-solid fa-user-secret', motivational: 'شما در سایه‌ها نیز قدرتمندید. با هوش و اراده، هر مشکلی را حل می‌کنید!' },
            { level: 15, name: 'سیگما', points: 4300, icon: 'fa-solid fa-chess-king', motivational: 'شما به اوج رسیده‌اید. با خرد و استراتژی، هر بازی را به نفع خود به پایان می‌رسانید!' }
        ];

        // Achievement data with Font Awesome icons
        const achievementsData = [
            // Level Achievements (remain as is)
            { level: 1, name: 'نوب', icon: 'fa-solid fa-ghost', type: 'level', description: 'شروع هر سفر با گام اول است. شما در ابتدای مسیر هستید و آماده برای کشف توانایی‌هایتان!' }, /* Changed icon to fa-ghost */
            { level: 2, name: 'مبتدی', icon: 'fa-solid fa-seedling', type: 'level', description: 'شما با تلاش و پشتکار، بذر موفقیت را کاشته‌اید. به رشد خود ادامه دهید!' },
            { level: 3, name: 'جنگجو', icon: 'fa-solid fa-hand-fist', type: 'level', description: 'شما با هر چالش، قوی‌تر و مصمم‌تر می‌شوید. روحیه جنگجویانه شما ستودنی است!' },
            { level: 4, name: 'شوالیه', icon: 'fa-solid fa-shield-halved', type: 'level', description: 'با هر وظیفه، زره‌ای از تجربه بر تن می‌کنید. شجاعت شما راهگشاست!' },
            { level: 5, name: 'هیرو', icon: 'fa-solid fa-mask', type: 'level', description: 'شما الهام‌بخش دیگران هستید. قدم‌هایتان ردپایی از موفقیت بر جای می‌گذارد!' },
            { level: 6, name: 'استاد', icon: 'fa-solid fa-graduation-cap', type: 'level', description: 'دانش و مهارت شما در حال شکوفایی است. از هر تجربه درسی بیاموزید!' },
            { level: 7, name: 'فرمانده', icon: 'fa-solid fa-star', type: 'level', description: 'اکنون می‌توانید رهبری کنید و مسیر را برای دیگران هموار سازید. قدرت در دستان شماست!' },
            { level: 8, name: 'سلطان', icon: 'fa-solid fa-crown', type: 'level', description: 'شما بر قلمرو وظایف خود مسلط شده‌اید. با اقتدار به سوی اهداف بزرگتر گام بردارید!' },
            { level: 9, name: 'کار درست', icon: 'fa-solid fa-dragon', type: 'level', description: 'شما به قدرتی بی‌نظیر دست یافته‌اید. هیچ مانعی جلودار شما نخواهد بود!' },
            { level: 10, name: 'خفن', icon: 'fa-solid fa-fire-alt', type: 'level', description: 'شما به یک ستاره درخشان تبدیل شده‌اید. انرژی و خلاقیت شما بی‌حد و مرز است و هر کاری را به بهترین شکل ممکن انجام می‌دهید!' },
            { level: 11, name: 'جاودان', points: 2000, icon: 'fa-solid fa-infinity', type: 'level', description: 'پشتکار شما بی‌حد و مرز است. این مسیر، راهی برای جاودانگی دستاوردهای شماست!' },
            { level: 12, name: 'کیهان‌سالار', points: 2500, icon: 'fa-solid fa-bolt', type: 'level', description: 'شما با سرعتی باورنکردنی در حال پیشرفت هستید. انرژی شما جهان را به حرکت درمی‌آورد!' },
            { level: 13, name: 'کیهان‌نورد', points: 3000, icon: 'fa-solid fa-rocket', type: 'level', description: 'شما مرزها را درنوردیده‌اید و به سوی ناشناخته‌ها پرواز می‌کنید. آسمان حد شما نیست!' },
            { level: 14, name: 'بتمن', points: 3600, icon: 'fa-solid fa-user-secret', type: 'level', description: 'شما در سایه‌ها نیز قدرتمندید. با هوش و اراده، هر مشکلی را حل می‌کنید!' },
            { level: 15, name: 'سیگما', points: 4300, icon: 'fa-solid fa-chess-king', type: 'level', description: 'شما به اوج رسیده‌اید. با خرد و استراتژی، هر بازی را به نفع خود به پایان می‌رسانید!' },
            // Total Tasks Achievements (Updated as per request)
            { type: 'totalTasks', value: 1, name: 'اولین قدم', icon: 'fa-solid fa-shoe-prints', description: 'اولین وظیفه خود را با موفقیت تکمیل کنید. هر سفر طولانی با یک قدم آغاز می‌شود!' },
            { type: 'totalTasks', value: 5, name: 'پنج ستاره', icon: 'fa-solid fa-star-half-stroke', description: 'با تکمیل ۵ وظیفه، نشان می‌دهید که در مسیر درستی هستید. به همین ترتیب ادامه دهید!' },
            { type: 'totalTasks', value: 10, name: 'ده وظیفه', icon: 'fa-solid fa-check-double', description: 'با تکمیل ۱۰ وظیفه، گام‌های محکم‌تری برداشته‌اید. این نشان از تعهد شماست و به شما کمک می‌کند تا به اهداف بزرگتر دست یابید.' },
            { type: 'totalTasks', value: 20, name: 'بیست وظیفه', icon: 'fa-solid fa-list-ol', description: 'بیست وظیفه را به پایان رساندید. این پیوستگی، پایه‌های موفقیت‌های آینده شما را بنا می‌نهد.' },
            { type: 'totalTasks', value: 50, name: 'پنجاه وظیفه', icon: 'fa-solid fa-clipboard-check', description: 'نیم قرن از وظایف را به اتمام رساندید! این حجم از کار، نشانگر توانایی شما در سازماندهی و پیگیری است.' },
            { type: 'totalTasks', value: 100, name: 'صد وظیفه', icon: 'fa-solid fa-trophy', description: 'به باشگاه صدتایی‌ها خوش آمدید! شما در حال ساختن عادت‌های موفقیت‌آمیز هستید و این ثبات, مسیر را برایتان هموارتر می‌کند.' },
            { type: 'totalTasks', value: 200, name: 'دویصد وظیفه', icon: 'fa-solid fa-medal', description: 'دویصد وظیفه تکمیل شده! این عدد، گواه رشد و پیشرفت مداوم شماست. به این روند ادامه دهید.' },
            { type: 'totalTasks', value: 300, name: 'سیصد وظیفه', icon: 'fa-solid fa-crown', description: 'سیصد وظیفه را با موفقیت پشت سر گذاشتید. شما در حال تسلط بر مدیریت زمان و بهره‌وری خود هستید.' },
            { type: 'totalTasks', value: 500, name: 'پانصد وظیفه', icon: 'fa-solid fa-award', description: 'پانصد وظیفه! این یک دستاورد بزرگ است که نشان می‌دهد شما در مسیر رسیدن به اهداف بزرگ، مصمم و قدرتمندید.' },
            { type: 'totalTasks', value: 1000, name: 'هزار وظیفه', icon: 'fa-solid fa-star', description: 'هزار وظیفه تکمیل شده! شما به یک اسطوره تبدیل شدید. این حجم از کار، نشان از اراده پولادین و توانایی بی‌نظیر شما در تحقق اهداف است.' },
            // Streak Achievements (remain as is)
            { type: 'streak', value: 3, name: 'زنجیره سه روزه', icon: 'fa-solid fa-fire', description: 'سه روز متوالی با انگیزه بالا! این شروع یک عادت عالی است.' },
            { type: 'streak', value: 7, name: 'زنجیره هفت روزه', icon: 'fa-solid fa-fire-flame-curved', description: 'یک هفته کامل از تلاش بی‌وقفه! زنجیره شما شعله‌ور است!' },
            { type: 'streak', value: 14, name: 'زنجیره دو هفته‌ای', icon: 'fa-solid fa-calendar-days', description: 'دو هفته مداوم! شما ثابت کردید که می‌توانید به اهداف بلندمدت خود پایبند باشید.' },
            { type: 'streak', value: 30, name: 'زنجیره ماهانه', icon: 'fa-solid fa-calendar-check', description: 'یک ماه کامل از تعهد و پشتکار! شما یک قهرمان بهره‌وری هستید.' },
            { type: 'streak', value: 60, name: 'زنجیره دو ماهه', icon: 'fa-solid fa-calendar-alt', description: 'شصت روز متوالی از تلاش و تعهد! شما الگوی پایداری هستید.' },
            { type: 'streak', value: 90, name: 'زنجیره سه ماهه', icon: 'fa-solid fa-calendar-check', description: 'نود روز مداوم! شما به یک عادت قدرتمند دست یافته‌اید.' },
            { type: 'streak', value: 180, name: 'زنجیره شش ماهه', icon: 'fa-solid fa-calendar-days', description: 'نیم سال کامل از بهره‌وری بی‌نظیر! شما واقعاً خارق‌العاده‌اید.' },
            { type: 'streak', value: 365, name: 'زنجیره یک ساله', icon: 'fa-solid fa-earth-americas', description: 'یک سال تمام از موفقیت‌های پی‌درپی! شما به یک افسانه تبدیل شده‌اید.' },
            // Points Achievements (remain as is)
            { type: 'points', value: 100, name: 'صد پوینت', icon: 'fa-solid fa-gem', description: 'اولین ۱۰۰ پوینت را کسب کردید. هر پوینت، گامی به سوی اهداف بزرگتر است!' },
            { type: 'points', value: 500, name: 'پانصد پوینت', icon: 'fa-solid fa-money-bill-wave', description: 'با جمع‌آوری ۵۰۰ پوینت، ارزش تلاش‌هایتان نمایان شده است.' },
            { type: 'points', value: 1000, name: 'هزار پوینت', icon: 'fa-solid fa-coins', description: 'هزار پوینت کسب کردید! شما در حال ساختن ثروت از جنس موفقیت هستید.' },
            { type: 'points', value: 2500, name: 'دو هزار و پانصد پوینت', icon: 'fa-solid fa-star-of-life', description: '۲۵۰۰ پوینت! شما در حال درخشش هستید و به اوج نزدیک می‌شوید.' },
            { type: 'points', value: 5000, name: 'پنج هزار پوینت', icon: 'fa-solid fa-meteor', description: '۵۰۰۰ پوینت! شما به یک نیروی غیرقابل توقف تبدیل شده‌اید. تبریک می‌گوییم!' },
            { type: 'points', value: 7500, name: 'هفت هزار و پانصد پوینت', icon: 'fa-solid fa-sack-dollar', description: 'با کسب ۷۵۰۰ پوینت، ارزش تلاش‌های شما به اوج رسیده است.' },
            { type: 'points', value: 10000, name: 'ده هزار پوینت', icon: 'fa-solid fa-money-bill-trend-up', description: 'ده هزار پوینت! شما به یک ثروت از جنس دستاوردها دست یافته‌اید.' },
            { type: 'points', value: 20000, name: 'بیست هزار پوینت', icon: 'fa-solid fa-hand-holding-usd', description: 'بیست هزار پوینت! شما فراتر از انتظار درخشیده‌اید و به یک اسطوره تبدیل شده‌اید.' },
            // First Pin Achievement (remain as is)
            { type: 'firstPin', value: 1, name: 'اولین پین', icon: 'fa-solid fa-thumbtack', description: 'اولین وظیفه خود را پین کردید. شما سازمان‌دهی را جدی می‌گیرید!' }
        ];

        // Motivation Quotes (45 quotes - psychological, value of tasks, step-by-step, small tasks)
        const motivationQuotes = [
            "هر قدم کوچک، پیشرفت بزرگیه.",
            "فقط شروع کن، بقیه‌اش میاد.",
            "پایداری، رمز موفقیت توئه.",
            "کارهای کوچیک، نتایج بزرگ میسازن.",
            "امروز رو بهترین روزت کن.",
            "تلاش کن، رویاهات زنده میشن.",
            "هر کار، یه قدم به هدفت نزدیکتر.",
            "باور کن، می‌تونی، انجامش بده.",
            "قدرتت همین الانه.",
            "کوچیک شروع کن، بزرگ فکر کن.",
            "هر روز، فرصت رشد داری.",
            "تغییر از درون خودته.",
            "بهترین خودت باش.",
            "پشتکار، سرنوشت رو میسازه.",
            "چالش‌ها، درس یادگیری هستن.",
            "تمرکز، قدرت آفرینشه.",
            "هر روز، یه قدم جلوتر.",
            "شادی تو عمل کردنشه.",
            "روی تلاشت تمرکز کن.",
            "انضباط، آزادی میاره.",
            "هر کار کوچیک، قوی‌ترت می‌کنه.",
            "به توانایی‌هات اعتماد کن.",
            "کمال‌گرایی، مانع عمله.",
            "همین الان شروع کن، نترس.",
            "تغییرات کوچیک، زندگی رو عوض می‌کنه.",
            "موفقیت، تکرار موفقیته.",
            "هر شکست، درس پیروزیه.",
            "به جای عالی، شروع کن.",
            "کارهای ناتمام رو تموم کن.",
            "با برنامه، به همه چی می‌رسی.",
            "ذهن آروم، عملکرد بهتر.",
            "هر روز، بهتر از دیروز باش.",
            "با اقدام، ترست رو از بین ببر.",
            "کوچیک اما پیوسته، برنده میشی.",
            "تلاش امروز، موفقیت فرداست.",
            "بهترین سرمایه‌گذاری، خودتی.",
            "هر کار، فرصت درخششه.",
            "با اراده، همه چی ممکنه.",
            "قدرت انتخاب با خودته.",
            "بهترین زمان، همین حالاست.",
            "از منطقه امنت بیا بیرون.",
            "هر روز، یه پیروزی کوچیکه.",
            "با انگیزه، کوه‌ها رو جابجا کن.",
            "به مسیرت ایمان داشته باش.",
            "تو قهرمان زندگی خودتی."
        ];


        // DOM elements
        // Removed themeToggleBtn and themeIcon
        const menuBtn = document.getElementById('menuBtn');
        const menuDropdown = document.getElementById('menuDropdown');
        const profileMenuItem = document.getElementById('profileMenuItem');
        const achievementsMenuItem = document.getElementById('achievementsMenuItem'); // New: Achievements menu item
        const helpMenuItem = document.getElementById('helpMenuItem');
        const aboutMenuItem = document.getElementById('aboutMenuItem');
        const backupMenuItem = document.getElementById('backupMenuItem');
        const updateAppMenuItem = document.getElementById('updateAppMenuItem'); // New: Update App menu item
        const donateMenuItem = document.getElementById('donateMenuItem');
        const resetMenuItem = document.getElementById('resetMenuItem');

        const pointsDropdownToggle = document.getElementById('pointsDropdownToggle'); // NEW
        const pointsDropdownContent = document.getElementById('pointsDropdownContent'); // NEW
        const dropdownIndicator = document.getElementById('dropdownIndicator'); // NEW

        const reorderBar = document.getElementById('reorderBar'); // New reorder bar
        const finishReorderBtn = document.getElementById('finishReorderBtn'); // New finish reorder button

        const welcomeModal = document.getElementById('welcomeModal');
        const welcomeModalContent = document.getElementById('welcomeModalContent');
        const userNameInput = document.getElementById('userNameInput');
        const startBtn = document.getElementById('startBtn');

        const profileModal = document.getElementById('profileModal');
        const profileModalContent = document.getElementById('profileModalContent');
        const closeProfileModalBtn = document.getElementById('closeProfileModalBtn');

        // New Achievements Modal elements
        const achievementsModal = document.getElementById('achievementsModal');
        const achievementsModalContent = document.getElementById('achievementsModalContent');
        const achievementsModalBody = document.getElementById('achievementsModalBody');
        const closeAchievementsModalBtn = document.getElementById('closeAchievementsModalBtn');

        // New Achievement Notification Modal elements
        const achievementNotificationModal = document.getElementById('achievementNotificationModal');
        const achievementNotificationModalContent = document.getElementById('achievementNotificationModalContent');
        const achievementNotificationIcon = document.getElementById('achievementNotificationIcon');
        const achievementNotificationTitle = document.getElementById('achievementNotificationTitle');
        const achievementNotificationMessage = document.getElementById('achievementNotificationMessage');
        const closeAchievementNotificationModalBtn = document.getElementById('closeAchievementNotificationModalBtn');


        const helpModal = document.getElementById('helpModal');
        const helpModalContent = document.getElementById('helpModalContent');
        const helpModalBody = document.getElementById('helpModalBody');
        const aboutModal = document.getElementById('aboutModal');
        const aboutModalContent = document.getElementById('aboutModalContent');
        const aboutModalBody = document.getElementById('aboutModalBody');
        const backupModal = document.getElementById('backupModal');
        const backupModalContent = document.getElementById('backupModalContent');
        const resetConfirmModal = document.getElementById('resetConfirmModal');
        const resetConfirmModalContent = document.getElementById('resetConfirmModalContent');
        const closeHelpModalBtn = document.getElementById('closeHelpModalBtn');
        const closeAboutModalBtn = document.getElementById('closeAboutModalBtn');
        const closeBackupModalBtn = document.getElementById('closeBackupModalBtn');
        const confirmResetBtn = document.getElementById('confirmResetBtn');
        const cancelResetBtn = document.getElementById('cancelResetBtn');
        const closeResetModalBtn = document.getElementById('closeResetModalBtn');
        const importFileInput = document.getElementById('importFileInput');
        const exportDataBtn = document.getElementById('exportDataBtn');
        const importDataBtn = document.getElementById('importDataBtn');
        const selectedFileNameSpan = document.getElementById('selectedFileName');

        const detailModal = document.getElementById('detailModal');
        const detailModalContent = document.getElementById('detailModalContent');
        const detailModalTitle = document.getElementById('detailModalTitle');
        const detailModalBody = document.getElementById('detailModalBody');
        const closeDetailModalBtn = document.getElementById('closeDetailModalBtn');

        const taskInput = document.getElementById('taskInput');
        const importanceSelect = document.getElementById('importanceSelect');
        const customPointsInput = document.getElementById('customPointsInput');
        const addTaskBtn = document.getElementById('addTaskBtn');
        const activeTaskList = document.getElementById('activeTaskList');
        const completedTasksContainer = document.getElementById('completedTasksContainer');
        const toggleCompletedTasksBtn = document.getElementById('toggleCompletedTasksBtn');
        const toggleIcon = document.getElementById('toggleIcon');
        const zPointSpan = document.getElementById('zPoint');
        const levelSpan = document.getElementById('level');
        // const currentLevelDisplay = document.getElementById('currentLevelDisplay'); // Removed, now handled by pointsDropdownToggle
        const levelIcon = document.getElementById('levelIcon'); // New: Level icon element
        const dailyStreakSpan = document.getElementById('dailyStreak');
        const progressBar = document.getElementById('progressBar');
        const progressText = document.getElementById('progressText');
        const addTaskSection = document.getElementById('addTaskSection');
        const addTaskTitle = document.getElementById('addTaskTitle');

        // Pagination DOM elements
        const activeTasksPagination = document.getElementById('activeTasksPagination');
        const completedTasksPagination = document.getElementById('completedTasksPagination');
        const completedTasksSection = document.getElementById('completedTasksSection'); // Container for completed tasks content

        const confettiContainer = document.getElementById('confettiContainer');

        // DOM elements for undo message box
        const undoMessageBox = document.getElementById('undoMessageBox');
        const undoMessageText = document.getElementById('undoMessageText');
        const undoCountdown = document.getElementById('undoCountdown');

        // Message queues for sequential display
        const notificationQueue = []; // Queue for top-right general messages
        let isNotificationDisplaying = false; // Flag to prevent simultaneous display of general notifications

        const achievementNotificationQueue = []; // NEW: Queue for achievement notifications
        let isAchievementNotificationDisplaying = false; // NEW: Flag for achievement notifications

        const bottomCenterMessageQueue = []; // Queue for bottom-center undo messages
        let isBottomCenterDisplaying = false;

        let currentCountdownInterval = null; // Holds the interval for the current countdown (if undo message)
        let currentBottomCenterTimeout = null;


        // Dynamic modal elements
        const editTaskModal = document.getElementById('editTaskModal');
        const editTaskModalContent = document.getElementById('editTaskModalContent'); // Correctly selected
        const editTaskNameInput = document.getElementById('editTaskNameInput');
        const editTaskImportanceSelect = document.getElementById('editTaskImportanceSelect');
        const editTaskCustomPointsInput = document.getElementById('editTaskCustomPointsInput');
        const saveEditedTaskBtn = document.getElementById('saveEditedTaskBtn');
        const cancelEditTaskBtn = document.getElementById('cancelEditTaskBtn');

        let currentTaskBeingEditedId = null; // To track the task currently being edited

        // New: Update Confirmation Modal elements
        const updateConfirmModal = document.getElementById('updateConfirmModal');
        const updateConfirmModalContent = document.getElementById('updateConfirmModalContent');
        const confirmUpdateBtn = document.getElementById('confirmUpdateBtn');
        const cancelUpdateBtn = document.getElementById('cancelUpdateBtn');
        const closeUpdateModalBtn = document.getElementById('closeUpdateModalBtn');

        // Motivation section elements
        const motivationContainer = document.getElementById('motivationContainer');
        const motivationTextSpan = document.getElementById('motivationText');
        let motivationInterval = null;


        // Helper function to convert Persian numbers to English
        function convertPersianNumbersToEnglish(inputString) {
            if (typeof inputString !== 'string') {
                return inputString; // Return as is if not a string
            }
            const persianNumbers = ['۰', '۱', '۲', '۳', '۴', '۵', '۶', '۷', '۸', '۹'];
            const englishNumbers = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];

            let convertedString = '';
            for (let i = 0; i < inputString.length; i++) {
                const char = inputString[i];
                const index = persianNumbers.indexOf(char);
                if (index !== -1) {
                    convertedString += englishNumbers[index];
                } else {
                    convertedString += char;
                }
            }
            return convertedString;
        }

        /**
         * Truncates a string to a specified length and appends '...' if truncated.
         * @param {string} text The input string.
         * @param {number} maxLength The maximum length before truncation.
         * @returns {string} The truncated or original string.
         */
        function truncateText(text, maxLength) {
            if (text.length > maxLength) {
                return text.substring(0, maxLength) + '...';
            }
            return text;
        }

        /**
         * Formats an ISO date string into a Persian date string including "سال".
         * Example: "پنجشنبه، ۶ خرداد سال ۱۴۰۳"
         * @param {string} isoDateString The ISO date string (e.g., "2023-05-25T10:00:00.000Z").
         * @returns {string} The formatted Persian date string or "نامشخص".
         */
        function formatPersianDate(isoDateString) {
            if (!isoDateString || isoDateString === 'null') return 'نامشخص';
            const date = new Date(isoDateString);
            const options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
            const parts = new Intl.DateTimeFormat('fa-IR', options).formatToParts(date);

            let weekday = '';
            let day = '';
            let month = '';
            let year = '';

            parts.forEach(part => {
                if (part.type === 'weekday') weekday = part.value;
                if (part.type === 'day') day = part.value;
                if (part.type === 'month') month = part.value;
                if (part.type === 'year') year = part.value;
            });

            // Reassemble in the desired order and insert "سال"
            return `${weekday}، ${day} ${month} ${year}`;
        }


        /**
         * Function to display a custom message box instead of alert().
         * Options can include: position ('top-right', 'bottom-center'), duration (ms), isUndo (boolean), taskData (for undo).
         * For achievement notifications, type should be 'achievement' with iconClass, title, and message.
         */
        function showMessageBox(message, type = 'info', options = {}) {
            const { position = 'top-right', duration = 3000, isUndo = false, taskData = null } = options;

            if (options.type === 'achievement') { // Separate handling for achievement notifications
                achievementNotificationQueue.push({ iconClass: options.iconClass, title: message, message: options.description });
                processAchievementNotificationQueue();
            } else if (position === 'top-right') {
                notificationQueue.push({ type: 'message', data: { message, msgType: type, duration } });
                processNotificationQueue();
            } else if (position === 'bottom-center') {
                bottomCenterMessageQueue.push({ message, type, position, duration, isUndo, taskData });
                processBottomCenterQueue();
            }
        }

        // Function to process the top-right notification queue (general messages)
        function processNotificationQueue() {
            // If welcome modal is currently visible, do not process other notifications yet.
            // They will be processed once welcome modal is closed.
            if (!welcomeModal.classList.contains('hidden')) {
                return;
            }

            if (notificationQueue.length === 0 || isNotificationDisplaying) {
                return;
            }

            isNotificationDisplaying = true;
            const notification = notificationQueue.shift(); // Get the next notification

            // This function now ONLY handles 'message' type notifications
            const messageBox = document.createElement('div');
            let bgColorClass = '';
            if (notification.data.msgType === 'info') {
                bgColorClass = 'bg-gray-500 dark:bg-gray-700';
            } else if (notification.data.msgType === 'success') {
                bgColorClass = 'bg-green-500 dark:bg-green-700';
            } else if (notification.data.msgType === 'error') {
                bgColorClass = 'bg-red-500 dark:bg-red-700';
            }
            messageBox.className = `fixed p-4 rounded-lg text-white z-50 transition-all duration-300 transform opacity-0 top-4 right-4 translate-x-full ${bgColorClass}`;
            messageBox.textContent = notification.data.message;
            document.body.appendChild(messageBox);

            setTimeout(() => {
                messageBox.classList.remove('translate-x-full', 'opacity-0');
                messageBox.classList.add('translate-x-0', 'opacity-100');
            }, 100);

            setTimeout(() => {
                messageBox.classList.remove('translate-x-0', 'opacity-100');
                messageBox.classList.add('translate-x-full', 'opacity-0');
                messageBox.addEventListener('transitionend', () => {
                    messageBox.remove();
                    isNotificationDisplaying = false;
                    processNotificationQueue(); // Process next message
                }, { once: true });
            }, notification.data.duration);
        }

        // Function to process the achievement notification queue
        function processAchievementNotificationQueue() {
            // If welcome modal is currently visible, or another achievement is displaying, do not process.
            if (!welcomeModal.classList.contains('hidden') || isAchievementNotificationDisplaying) {
                return;
            }
            if (achievementNotificationQueue.length === 0) {
                return;
            }

            isAchievementNotificationDisplaying = true;
            const achievement = achievementNotificationQueue.shift(); // Get the next achievement notification

            achievementNotificationIcon.className = achievement.iconClass;
            achievementNotificationTitle.textContent = achievement.title;
            achievementNotificationMessage.textContent = achievement.message;

            // Apply inline styles directly to the icon element for maximum specificity
            achievementNotificationIcon.style.fontSize = '4.5rem'; /* 7xl */
            achievementNotificationIcon.style.display = 'flex';
            achievementNotificationIcon.style.alignItems = 'center';
            achievementNotificationIcon.style.justifyContent = 'center';
            achievementNotificationIcon.style.marginBottom = '5px'; /* 5 pixels from bottom */


            achievementNotificationModal.classList.remove('hidden');
            void achievementNotificationModalContent.offsetWidth; // Force reflow
            achievementNotificationModalContent.classList.remove('opacity-0', 'scale-95');
            achievementNotificationModalContent.classList.add('opacity-100', 'scale-100');
            triggerConfetti();
            // The close button for this modal will set isAchievementNotificationDisplaying = false and call processAchievementNotificationQueue()
        }

        // Function to process the bottom-center message queue (for undo messages)
        function processBottomCenterQueue() {
            if (bottomCenterMessageQueue.length === 0 || isBottomCenterDisplaying) {
                return;
            }

            isBottomCenterDisplaying = true;
            const { message, duration, isUndo, taskData } = bottomCenterMessageQueue.shift();

            // Only undoMessageBox uses bottom-center position and undo logic
            if (isUndo) {
                undoMessageText.textContent = message;
                undoMessageBox.classList.remove('hidden'); // Ensure it's not hidden
                undoMessageBox._currentUndoTaskData = taskData; // Store specific task data for this message

                let timeLeft = duration / 1000;
                undoCountdown.textContent = `(${timeLeft}s)`;
                clearInterval(currentCountdownInterval); // Clear previous interval
                currentCountdownInterval = setInterval(() => {
                    timeLeft--;
                    undoCountdown.textContent = `(${timeLeft}s)`;
                    if (timeLeft <= 0) {
                        clearInterval(currentCountdownInterval);
                        hideBottomCenterMessage(); // Hide undo message
                    }
                }, 1000);

                undoMessageBox.onclick = () => {
                    if (undoMessageBox._currentUndoTaskData) {
                        undoLastDeletion(undoMessageBox._currentUndoTaskData);
                    }
                    hideBottomCenterMessage(); // Hide undo message immediately on click
                };

                // Entry animation
                setTimeout(() => {
                    undoMessageBox.classList.remove('scale-0', 'opacity-0');
                    undoMessageBox.classList.add('scale-100', 'opacity-100');
                }, 100);

                currentBottomCenterTimeout = setTimeout(() => {
                    hideBottomCenterMessage();
                }, duration);
            }

            function hideBottomCenterMessage() {
                clearTimeout(currentBottomCenterTimeout);
                clearInterval(currentCountdownInterval);
                undoMessageBox.classList.remove('scale-100', 'opacity-100');
                undoMessageBox.classList.add('scale-0', 'opacity-0');
                undoMessageBox.addEventListener('transitionend', () => {
                    undoMessageBox.classList.add('hidden'); // Fully hide after animation
                    undoMessageBox.onclick = null; // Remove click handler
                    undoMessageBox._currentUndoTaskData = null; // Clear stored task data
                    isBottomCenterDisplaying = false;
                    processBottomCenterQueue(); // Process next message
                }, { once: true });
            }
        }


        // Function to show point gain feedback
        function showPointsGainFeedback(pointsGained, taskElement) {
            if (!taskElement) return;

            const feedback = document.createElement('div');
            feedback.textContent = `${pointsGained} پوینت`;
            feedback.classList.add('points-gain-feedback');

            // Position feedback element relative to the task item
            const rect = taskElement.getBoundingClientRect();
            feedback.style.top = `${rect.top + window.scrollY + rect.height / 2 - 10}px`;
            feedback.style.left = `${rect.left + window.scrollX + rect.width / 2 - 20}px`;
            feedback.style.fontSize = '1.2rem'; // Slightly increased font size

            document.body.appendChild(feedback);

            feedback.addEventListener('animationend', () => {
                feedback.remove();
            });
        }

        // Function to trigger confetti effect
        function triggerConfetti() {
            const colors = ['#f0f', '#0ff', '#ff0', '#f00', '#0f0', '#00f'];
            for (let i = 0; i < 50; i++) { // Generate 50 confetti pieces
                const confetti = document.createElement('div');
                confetti.classList.add('confetti');
                confetti.style.left = `${Math.random() * 100}vw`;
                confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                confetti.style.animationDelay = `${Math.random() * 0.5}s`; // Animate with delay
                confettiContainer.appendChild(confetti);
            }
            // Cleanup confetti after animation
            setTimeout(() => {
                confettiContainer.innerHTML = '';
            }, 3000);
        }

        // Function to apply theme based on current level (modified for minimal theme)
        function applyLevelTheme(currentLevel) {
            const isDarkMode = document.documentElement.classList.contains('dark');

            // Define blue color palette based on Tailwind CSS classes
            const lightThemeColors = {
                primary: '#2563eb', /* blue-600 */
                secondary: '#1d4ed8', /* blue-700 */
                accentBg: '#eff6ff', /* blue-50 */
                accentText: '#1e3a8a', /* blue-900 */
                inputBorder: '#93c5fd', /* blue-300 */
                inputFocusRing: '#60a5fa', /* blue-400 */
                motivationIcon: '#2563eb' /* blue-600 */
            };
            const darkThemeColors = {
                primary: '#93c5fd', /* blue-300 */
                secondary: '#60a5fa', /* blue-400 */
                accentBg: '#1e3a8a', /* blue-900 */
                accentText: '#eff6ff', /* blue-50 */
                inputBorder: '#2563eb', /* blue-600 */
                inputFocusRing: '#3b82f6', /* blue-500 */
                motivationIcon: '#93c5fd' /* blue-300 */
            };

            const currentThemeData = isDarkMode ? darkThemeColors : lightThemeColors;

            // Set CSS variables
            document.documentElement.style.setProperty('--theme-primary', currentThemeData.primary);
            document.documentElement.style.setProperty('--theme-secondary', currentThemeData.secondary);
            document.documentElement.style.setProperty('--theme-accent-bg', currentThemeData.accentBg);
            document.documentElement.style.setProperty('--theme-accent-text', currentThemeData.accentText);
            document.documentElement.style.setProperty('--theme-progress-from', currentThemeData.primary);
            document.documentElement.style.setProperty('--theme-progress-to', currentThemeData.secondary);
            document.documentElement.style.setProperty('--theme-input-border', currentThemeData.inputBorder);
            document.documentElement.style.setProperty('--theme-input-focus-ring', currentThemeData.inputFocusRing);
            document.documentElement.style.setProperty('--theme-blue-motivation-icon', currentThemeData.motivationIcon);


            // Update elements that use these variables
            // Add task button
            addTaskBtn.style.backgroundColor = currentThemeData.primary;
            addTaskBtn.onmouseover = () => addTaskBtn.style.backgroundColor = currentThemeData.secondary;
            addTaskBtn.onmouseout = () => addTaskBtn.style.backgroundColor = currentThemeData.primary;

            // Update progress bar gradient
            progressBar.style.backgroundImage = `linear-gradient(to right, ${currentThemeData.primary}, ${currentThemeData.secondary})`;
        }

        // Helper function to convert hex color code to RGB format (not used in current minimal theme logic)
        function hexToRgb(hex) {
            const bigint = parseInt(hex.slice(1), 16);
            const r = (bigint >> 16) & 255;
            const g = (bigint >> 8) & 255;
            const b = bigint & 255;
            return `${r}, ${g}, ${b}`;
        }

        // Function to update gamification display
        function updateGamificationDisplay() {
            // If userName is not set, defer gamification display until it is.
            if (!userName) {
                return;
            }

            const oldLevel = level; // Store the current level before potential update

            zPointSpan.textContent = zPoint;

            let newLevel = 1;
            let currentLevelInfo = levelPointsThresholds[0]; // Default to level 1
            for (let i = 0; i < levelPointsThresholds.length; i++) {
                if (zPoint >= levelPointsThresholds[i].points) {
                    newLevel = i + 1;
                    currentLevelInfo = levelPointsThresholds[i];
                } else {
                    break; // Points are not enough for this level, so previous level is current
                }
            }

            // Check if level has actually changed OR if it's the "Noob" level and hasn't been unlocked yet
            if (newLevel !== level || (newLevel === 1 && !unlockedAchievements.includes('نوب'))) {
                // Trigger achievement for each level gained between oldLevel and newLevel
                // Or specifically for 'نوب' if it's level 1 and not yet unlocked
                for (let i = oldLevel; i < newLevel; i++) {
                    const achievedLevelInfo = levelPointsThresholds[i]; // i is 0-indexed, so corresponds to level (i+1)
                    if (achievedLevelInfo && !unlockedAchievements.includes(achievedLevelInfo.name)) {
                        unlockedAchievements.push(achievedLevelInfo.name);
                        achievementUnlockDates[achievedLevelInfo.name] = new Date().toISOString();
                        console.log(`Achievement Unlocked: ${achievedLevelInfo.name}`); // Log for debugging
                        // Add to queue immediately for sequential display
                        showMessageBox(`دستاورد: ${achievedLevelInfo.name}`, 'success', {
                            type: 'achievement',
                            iconClass: achievedLevelInfo.icon,
                            description: achievedLevelInfo.motivational // Use motivational text for level achievements
                        });
                    }
                }
                // Special handling for 'نوب' (Level 1) if it wasn't triggered by the loop
                if (newLevel === 1 && !unlockedAchievements.includes('نوب')) {
                    const noobAchievement = levelPointsThresholds[0];
                    unlockedAchievements.push(noobAchievement.name);
                    achievementUnlockDates[noobAchievement.name] = new Date().toISOString();
                    console.log(`Achievement Unlocked: ${noobAchievement.name}`);
                    showMessageBox(`دستاورد: ${noobAchievement.name}`, 'success', {
                        type: 'achievement',
                        iconClass: noobAchievement.icon,
                        description: noobAchievement.motivational
                    });
                }

                level = newLevel; // Update global level variable AFTER processing all intermediate achievements
            }
            levelSpan.textContent = level;

            // Update dynamic level icon
            levelIcon.className = `${currentLevelInfo.icon} text-xl ml-2`; // Apply the icon class

            dailyStreakSpan.textContent = dailyStreak + " روز"; // Update daily streak display with " روز"

            // Progress bar logic up to level 15
            if (level <= levelPointsThresholds.length) {
                const currentLevelThreshold = levelPointsThresholds[level - 1].points;
                // Ensure correct nextLevelThreshold calculation, especially for the last level
                const nextLevelThreshold = (level < levelPointsThresholds.length) ? levelPointsThresholds[level].points : levelPointsThresholds[levelPointsThresholds.length - 1].points;

                let pointsIntoCurrentLevel = zPoint - currentLevelThreshold;
                let pointsNeededForNextLevel = nextLevelThreshold - currentLevelThreshold;

                let progressPercentage = 0;
                if (pointsNeededForNextLevel > 0) {
                    progressPercentage = Math.min(100, (pointsIntoCurrentLevel / pointsNeededForNextLevel) * 100);
                } else if (level === levelPointsThresholds.length) { // Max level reached
                    progressPercentage = 100;
                }

                progressBar.style.width = `${progressPercentage}%`;
                if (level < levelPointsThresholds.length) {
                    progressText.textContent = `شما ${Math.round(progressPercentage)}% از مسیر پیشرفت به سطح ${levelPointsThresholds[level].name} را طی کرده‌اید.`;
                } else {
                    progressText.textContent = `شما به حداکثر سطح (${levelPointsThresholds[levelPointsThresholds.length - 1].name}) رسیده‌اید! شما می‌توانید همچنان پوینت کسب کنید!`;
                }
            } else {
                // After max level, progress bar remains full and only points accumulate
                progressBar.style.width = `100%`;
                progressText.textContent = `شما به حداکثر سطح (${levelPointsThresholds[levelPointsThresholds.length - 1].name}) رسیده‌اید! شما می‌توانید همچنان پوینت کسب کنید!`;
            }

            // Check for other achievements (totalTasks, streak, points, firstPin)
            const currentTotalTasksCompleted = tasks.filter(task => task.completed).length;

            achievementsData.forEach(achievement => {
                // Skip level achievements as they are handled above
                if (achievement.type === 'level') return;

                let isAchieved = false;
                if (achievement.type === 'streak') {
                    if (dailyStreak >= achievement.value) {
                        isAchieved = true;
                    }
                } else if (achievement.type === 'totalTasks') {
                    if (currentTotalTasksCompleted >= achievement.value) {
                        isAchieved = true;
                    }
                } else if (achievement.type === 'points') {
                    if (zPoint >= achievement.value) {
                        isAchieved = true;
                    }
                } else if (achievement.type === 'firstPin') {
                    if (hasPinnedTaskEver) {
                        isAchieved = true;
                    }
                }

                if (isAchieved && !unlockedAchievements.includes(achievement.name)) {
                    unlockedAchievements.push(achievement.name);
                    achievementUnlockDates[achievement.name] = new Date().toISOString();
                    console.log(`Achievement Unlocked: ${achievement.name}`); // Log for debugging
                    showMessageBox(`دستاورد: ${achievement.name}`, 'success', {
                        type: 'achievement',
                        iconClass: achievement.icon,
                        description: achievement.description
                    });
                }
            });

            saveToLocalStorage(); // Save all updated data
            applyLevelTheme(level); // Apply theme for current level
        }

        // Function to save tasks, points, level, streak, and last completion date to Local Storage
        function saveToLocalStorage() {
            localStorage.setItem('tasks', JSON.stringify(tasks));
            localStorage.setItem('zPoint', zPoint);
            localStorage.setItem('level', level);
            localStorage.setItem('dailyStreak', dailyStreak);
            localStorage.setItem('highestDailyStreak', highestDailyStreak); // Save highest streak
            localStorage.setItem('lastCompletionDate', lastCompletionDate);
            localStorage.setItem('totalCustomTasksCompleted', totalCustomTasksCompleted);
            localStorage.setItem('userName', userName);
            localStorage.setItem('userCreationDate', userCreationDate); // Save user creation date
            localStorage.setItem('unlockedAchievements', JSON.stringify(unlockedAchievements)); // Save unlocked achievements
            localStorage.setItem('achievementUnlockDates', JSON.stringify(achievementUnlockDates)); // Save achievement unlock dates
            localStorage.setItem('hasPinnedTaskEver', hasPinnedTaskEver); // Save new flag
            localStorage.setItem('currentMotivationIndex', currentMotivationIndex); // Save current motivation index
            // Theme is saved separately in initializeTheme/themeToggleBtn
        }

        // Function to load tasks, points, level, streak, and last completion date from Local Storage
        function loadFromLocalStorage() {
            const storedTasks = localStorage.getItem('tasks');
            const storedZPoint = localStorage.getItem('zPoint');
            const storedLevel = localStorage.getItem('level');
            const storedDailyStreak = localStorage.getItem('dailyStreak');
            const storedHighestDailyStreak = localStorage.getItem('highestDailyStreak'); // Load highest streak
            const storedLastCompletionDate = localStorage.getItem('lastCompletionDate');
            const storedTotalCustomTasksCompleted = localStorage.getItem('totalCustomTasksCompleted');
            const storedUserName = localStorage.getItem('userName');
            const storedUserCreationDate = localStorage.getItem('userCreationDate'); // Load user creation date
            const storedUnlockedAchievements = localStorage.getItem('unlockedAchievements'); // Load unlocked achievements
            const storedAchievementUnlockDates = localStorage.getItem('achievementUnlockDates'); // Load achievement unlock dates
            const storedHasPinnedTaskEver = localStorage.getItem('hasPinnedTaskEver'); // Load new flag
            const storedCurrentMotivationIndex = localStorage.getItem('currentMotivationIndex'); // Load motivation index

            if (storedTasks) {
                try {
                    tasks = JSON.parse(storedTasks);
                    // Ensure all loaded tasks have the isPinned and pinnedAt properties
                    tasks.forEach(task => {
                        if (typeof task.isPinned === 'undefined') {
                            task.isPinned = false;
                        }
                        if (typeof task.pinnedAt === 'undefined') {
                            task.pinnedAt = null;
                        }
                    });
                } catch (e) {
                    console.error("Error parsing stored tasks from Local Storage:", e);
                    tasks = []; // Reset tasks if parsing fails
                }
            }
            if (storedZPoint) {
                zPoint = parseInt(storedZPoint, 10);
                if (isNaN(zPoint)) zPoint = 0; // Ensure it's a number
            }
            if (storedLevel) {
                level = parseInt(storedLevel, 10);
                if (isNaN(level)) level = 1; // Ensure it's a number
            }
            if (storedDailyStreak) {
                dailyStreak = parseInt(storedDailyStreak, 10);
                if (isNaN(dailyStreak)) dailyStreak = 0; // Ensure it's a number
            }
            if (storedHighestDailyStreak) { // Parse highest streak
                highestDailyStreak = parseInt(storedHighestDailyStreak, 10);
                if (isNaN(highestDailyStreak)) highestDailyStreak = 0;
            }
            if (storedTotalCustomTasksCompleted) {
                totalCustomTasksCompleted = parseInt(storedTotalCustomTasksCompleted, 10);
                if (isNaN(totalCustomTasksCompleted)) totalCustomTasksCompleted = 0; // Ensure it's a number
            }
            // userName is handled in window.onload for initial check
            if (storedUserCreationDate && storedUserCreationDate !== 'null') {
                userCreationDate = storedUserCreationDate;
            } else {
                userCreationDate = null;
            }
            if (storedUnlockedAchievements) {
                try {
                    unlockedAchievements = JSON.parse(storedUnlockedAchievements);
                } catch (e) {
                    console.error("Error parsing unlocked achievements from Local Storage:", e);
                    unlockedAchievements = [];
                }
            }
            if (storedAchievementUnlockDates) {
                try {
                    achievementUnlockDates = JSON.parse(storedAchievementUnlockDates);
                } catch (e) {
                    console.error("Error parsing achievement unlock dates from Local Storage:", e);
                    achievementUnlockDates = {};
                }
            } else {
                // If achievementUnlockDates is not found (old version), populate it with current unlockedAchievements
                unlockedAchievements.forEach(achName => {
                    if (!achievementUnlockDates[achName]) {
                        achievementUnlockDates[achName] = new Date().toISOString(); // Set current date as unlock date
                    }
                });
            }

            if (storedHasPinnedTaskEver) {
                hasPinnedTaskEver = (storedHasPinnedTaskEver === 'true'); // Convert string to boolean
            }
            // Handle 'null' string from localStorage
            if (storedLastCompletionDate && storedLastCompletionDate !== 'null') {
                lastCompletionDate = storedLastCompletionDate;
            } else {
                lastCompletionDate = null; // Explicitly set to null if not found or was 'null' string
            }

            if (storedCurrentMotivationIndex) {
                currentMotivationIndex = parseInt(storedCurrentMotivationIndex, 10);
                if (isNaN(currentMotivationIndex)) currentMotivationIndex = 0;
            } else {
                currentMotivationIndex = 0;
            }


            // Check and update daily streak on load
            const today = new Date().toDateString();

            if (lastCompletionDate && lastCompletionDate !== today) {
                const lastDate = new Date(lastCompletionDate);
                const yesterday = new Date();
                yesterday.setDate(yesterday.getDate() - 1);

                // Compare only date parts for streak
                if (lastDate.toDateString() === yesterday.toDateString()) {
                    dailyStreak++;
                } else if (lastDate.toDateString() !== today) {
                    dailyStreak = 0; // Reset if not consecutive and today hasn't been completed yet
                    showMessageBox('زنجیره روزانه شما بازنشانی شد.', 'info');
                }
            } else if (!lastCompletionDate) { // If no completion date exists
                dailyStreak = 0;
            }
            highestDailyStreak = Math.max(highestDailyStreak, dailyStreak); // Ensure highest is updated on load too
            saveToLocalStorage(); // Save updated streak if reset
        }

        /**
         * Function to re-evaluate and update the daily streak after importing data.
         * This is necessary because the initial load logic might have run before import.
         */
        function updateDailyStreakOnImport() {
            const today = new Date().toDateString();

            // Only proceed if lastCompletionDate is not null and is a valid date string
            if (lastCompletionDate && lastCompletionDate !== 'null') {
                const lastDate = new Date(lastCompletionDate);
                const yesterday = new Date();
                yesterday.setDate(yesterday.getDate() - 1);

                // If last completion was yesterday, continue streak
                if (lastDate.toDateString() === yesterday.toDateString()) {
                    // Streak continues, no need to change dailyStreak if it was already correctly loaded
                    // We only need to ensure it's not incorrectly reset if it was already continuous.
                    // If the imported lastCompletionDate is today, streak should not be affected.
                    // If imported lastCompletionDate is yesterday, streak should be current + 1.
                    // If imported lastCompletionDate is older than yesterday, streak should be 0.

                    // To simplify, let's re-calculate from scratch based on imported lastCompletionDate
                    if (lastDate.toDateString() === today) {
                        // If last completion was today, streak is already correct (from imported value)
                        // No change needed to dailyStreak
                    } else if (lastDate.toDateString() === yesterday.toDateString()) {
                        dailyStreak = (dailyStreak === 0 ? 1 : dailyStreak + 1); // Increment if it was 0 or more
                    } else {
                        dailyStreak = 0; // Reset if older than yesterday
                        showMessageBox('زنجیره روزانه شما پس از بازیابی بازنشانی شد.', 'info');
                    }
                } else if (lastDate.toDateString() !== today) {
                    // If last completion date is not today and not yesterday, reset streak
                    dailyStreak = 0;
                    showMessageBox('زنجیره روزانه شما پس از بازیابی بازنشانی شد.', 'info');
                }
            } else { // If lastCompletionDate is null or 'null'
                dailyStreak = 0;
            }
            highestDailyStreak = Math.max(highestDailyStreak, dailyStreak); // Update highest streak
            saveToLocalStorage(); // Save updated streak after import
        }


        /**
         * Creates a new HTML element for a task.
         * @param {object} task - The task object.
         * @param {boolean} [isNew=false] - True if this is a newly added task, for animation.
         * @param {boolean} [inReorderMode=false] - True if currently in reordering mode.
         * @param {string|null} [reorderingTaskId=null] - The ID of the task currently being reordered.
         * @returns {HTMLElement} The created task item element.
         */
        function createTaskElement(task, isNew = false, inReorderMode = false, reorderingTaskId = null) {
            const taskItem = document.createElement('div');
            // Apply dark mode classes based on status and importance of task
            taskItem.className = `task-item flex items-center justify-between p-3 mb-2 sm:p-4 sm:mb-3 rounded-lg transition-all duration-300 ease-in-out
                                ${task.completed ? 'bg-green-100 dark:bg-green-800 border-l-4 border-green-500 dark:border-green-600 line-through text-gray-500 dark:text-gray-400' :
                                task.isPinned ? 'bg-yellow-50 dark:bg-yellow-900 border-l-4 border-yellow-500 dark:border-yellow-600' : // Pinned style
                                task.importance === 'important' ? 'bg-red-50 dark:bg-red-900 border-l-4 border-red-500 dark:border-red-600' :
                                task.importance === 'custom' ? 'bg-purple-50 dark:bg-purple-900 border-l-4 border-purple-500 dark:border-purple-600' :
                                task.importance === 'note' ? 'bg-orange-50 dark:bg-orange-900 border-l-4 border-orange-500 dark:border-orange-600' : // Note style
                                'bg-gray-50 dark:bg-gray-700 border-l-4 border-gray-300 dark:border-gray-600'}
                                ${isNew ? 'new-task-animation' : ''}
                                ${inReorderMode && task.id !== reorderingTaskId ? 'reordering-disabled' : ''}
                                ${inReorderMode && task.id === reorderingTaskId ? 'reordering-active' : ''}`;
            taskItem.dataset.id = task.id;

            // Determine importance display text
            let importanceText = '';
            let importanceClasses = '';
            if (task.importance === 'important') {
                importanceText = 'مهم';
                importanceClasses = 'bg-red-200 dark:bg-red-700 text-red-800 dark:text-red-200';
            } else if (task.importance === 'normal') {
                importanceText = 'عادی';
                importanceClasses = 'bg-gray-200 dark:bg-gray-600 text-gray-700 dark:text-gray-200';
            } else if (task.importance === 'custom') {
                importanceText = `${task.customPoints} پوینت`; // Display custom points as "35 points"
                importanceClasses = 'bg-purple-200 dark:bg-purple-700 text-purple-800 dark:text-purple-200';
            } else if (task.importance === 'note') { // New: Note importance
                importanceText = 'یادداشت';
                importanceClasses = 'bg-orange-200 dark:bg-orange-700 text-orange-800 dark:text-orange-200';
            }

            let actionButtonsHtml = '';
            if (inReorderMode && task.id === reorderingTaskId) {
                // Show up/down arrows in reordering mode for the active task
                // Changed classes for smaller, more minimal buttons
                actionButtonsHtml = `
                    <button data-id="${task.id}" data-action="move-up"
                        class="h-7 w-7 flex items-center justify-center rounded-full bg-blue-200 hover:bg-blue-300 dark:bg-blue-700 dark:hover:bg-blue-600 text-blue-800 dark:text-blue-100 transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-blue-400">
                        <i class="fa-solid fa-arrow-up text-sm"></i>
                    </button>
                    <button data-id="${task.id}" data-action="move-down"
                        class="h-7 w-7 flex items-center justify-center rounded-full bg-blue-200 hover:bg-blue-300 dark:bg-blue-700 dark:hover:bg-blue-600 text-blue-800 dark:text-blue-100 transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-blue-400">
                        <i class="fa-solid fa-arrow-down text-sm"></i>
                    </button>
                `;
            } else {
                // Show standard menu button
                actionButtonsHtml = `
                    <button data-id="${task.id}" data-action="menu"
                        class="three-dot-menu-btn bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 text-gray-800 dark:text-gray-100 transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-blue-400">
                        <svg class="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 5v.01M12 12v.01M12 19v.01M12 6a1 1 0 100-2 1 1 0 000 2zm0 7a1 1 0 100-2 1 1 0 000 2zm0 7a1 1 0 100-2 1 1 0 000 2z"></path>
                        </svg>
                    </button>
                `;
            }

            // Conditional rendering for checkbox and clickability
            const checkboxHtml = task.importance !== 'note' ? `
                <input type="checkbox" data-id="${task.id}" ${task.completed ? 'checked' : ''}
                    class="form-checkbox h-5 w-5 text-blue-600 dark:text-blue-400 rounded focus:ring-blue-500 dark:focus:ring-blue-300 ml-2">
            ` : '';

            // Apply text-align-justify-rtl class only for notes
            const justifyClass = task.importance === 'note' ? 'text-align-justify-rtl' : '';

            // Dynamic icon for notes: show only if not pinned
            const noteIconHtml = (task.importance === 'note' && !task.isPinned) ?
                `<i class="fa-solid fa-note-sticky ml-2 text-orange-500" title="یادداشت"></i>` : '';

            taskItem.innerHTML = `
                <div class="flex items-center flex-grow">
                    ${checkboxHtml}
                    <div class="task-name-wrapper ${task.importance !== 'note' ? 'ml-3' : ''} text-base sm:text-lg font-medium ${task.completed ? 'text-gray-500 dark:text-gray-400 line-through' : 'text-gray-800 dark:text-gray-100'} ${justifyClass}">
                        ${task.isPinned ? `<i class="fa-solid fa-thumbtack ml-2 text-yellow-500" title="وظیفه پین شده"></i>` : ''}
                        ${noteIconHtml}
                        <span class="task-name">${task.name}</span>
                    </div>
                </div>
                <div class="flex items-center space-x-2 space-x-reverse mr-2">
                    <span class="task-importance-display text-sm px-2 py-1 rounded-full mr-2 ${importanceClasses}">
                        ${importanceText}
                    </span>
                    ${actionButtonsHtml}
                </div>
            `;

            if (isNew) {
                // Trigger fade-in animation for new tasks
                setTimeout(() => {
                    taskItem.classList.add('animate-in');
                }, 10);
            }

            return taskItem;
        }

        // Function to render tasks
        function renderTasks(focusTaskId = null) {
            // Get current active and completed tasks from the data model
            let activeTasks = tasks.filter(task => !task.completed);
            const completedTasks = tasks.filter(task => task.completed); // Corrected 't.completed' to 'task.completed'

            // Sort active tasks: pinned first (newest pinned at top), then maintain relative order (manual order)
            activeTasks.sort((a, b) => {
                // Primary sort: Pinned tasks first
                if (a.isPinned && !b.isPinned) return -1;
                if (!a.isPinned && b.isPinned) return 1;

                // Secondary sort for pinned tasks: newest pinned first (descending pinnedAt)
                if (a.isPinned && b.isPinned) {
                    const dateA = new Date(a.pinnedAt || 0); // Use 0 for tasks without pinnedAt (older backups)
                    const dateB = new Date(b.pinnedAt || 0);
                    return dateB.getTime() - dateA.getTime(); // Newest pinned first
                }

                // Tertiary sort for unpinned tasks: maintain original order
                // This assumes the `tasks` array itself is generally ordered by creation or manual reorder.
                return 0;
            });

            // Dynamic Page Calculation based on focusTaskId
            if (focusTaskId) {
                const focusedTask = tasks.find(t => t.id === focusTaskId);
                if (focusedTask) {
                    if (!focusedTask.completed) { // If focused task is active
                        const indexInActiveList = activeTasks.findIndex(t => t.id === focusTaskId);
                        if (indexInActiveList !== -1) {
                            activeCurrentPage = Math.ceil((indexInActiveList + 1) / TASKS_PER_PAGE);
                        }
                    } else { // If focused task is completed
                        const indexInCompletedList = completedTasks.findIndex(t => t.id === focusTaskId);
                        if (indexInCompletedList !== -1) {
                            completedCurrentPage = Math.ceil((indexInCompletedList + 1) / TASKS_PER_PAGE);
                            // Also ensure completed tasks section is visible if a completed task is focused
                            if (completedTasksSection.classList.contains('hidden')) {
                                completedTasksSection.classList.remove('hidden');
                                toggleIcon.classList.add('rotate-180'); // Ensure icon is rotated
                            }
                        }
                    }
                }
            }
            // End Dynamic Page Calculation

            // Handle active tasks rendering
            const activeTotalPages = Math.ceil(activeTasks.length / TASKS_PER_PAGE);
            if (activeCurrentPage > activeTotalPages && activeTotalPages > 0) {
                activeCurrentPage = activeTotalPages;
            } else if (activeTotalPages === 0) {
                activeCurrentPage = 1;
            }
            activeCurrentPage = Math.min(Math.max(1, activeCurrentPage), Math.max(1, activeTotalPages));

            const activeStartIndex = (activeCurrentPage - 1) * TASKS_PER_PAGE;
            const activeEndIndex = activeStartIndex + TASKS_PER_PAGE;
            const activeTasksToRender = activeTasks.slice(activeStartIndex, activeEndIndex);

            updateTaskListDOM(activeTaskList, activeTasksToRender, activeTasks.length === 0, 'اولین وظیفه فعال خود را ایجاد کنید!', isReorderingMode, reorderingTaskId, focusTaskId);

            // Handle completed tasks rendering
            const completedTotalPages = Math.ceil(completedTasks.length / TASKS_PER_PAGE);
            if (completedCurrentPage > completedTotalPages && completedTotalPages > 0) {
                completedCurrentPage = completedTotalPages; // FIX: Changed from 'totalPages' to 'completedTotalPages'
            } else if (completedTotalPages === 0) {
                completedCurrentPage = 1;
            }
            completedCurrentPage = Math.min(Math.max(1, completedCurrentPage), Math.max(1, completedTotalPages));

            const completedStartIndex = (completedCurrentPage - 1) * TASKS_PER_PAGE;
            const completedEndIndex = completedStartIndex + TASKS_PER_PAGE;
            const completedTasksToRender = completedTasks.slice(completedStartIndex, completedEndIndex);

            // Pass null for focusTaskId for completed tasks unless specifically needed (e.g., undo)
            updateTaskListDOM(completedTasksContainer, completedTasksToRender, completedTasks.length === 0, 'هنوز وظیفه تکمیل شده‌ای وجود ندارد.', false, null, focusTaskId); // Completed tasks are never in reorder mode

            // Render pagination controls for both lists
            renderPaginationControls(activeTasksPagination, activeTasks.length, activeCurrentPage, 'active');
            renderPaginationControls(completedTasksPagination, completedTasks.length, completedCurrentPage, 'completed');

            // Show/hide "Done Reordering" button (now the reorder bar)
            if (isReorderingMode) {
                // Force reflow to ensure hidden is removed before transition starts (if it was initially hidden by CSS)
                void reorderBar.offsetWidth;
                setTimeout(() => { // Then remove opacity and pointer-events
                    reorderBar.classList.remove('opacity-0', 'pointer-events-none');
                }, 10); // Small delay to ensure transition applies
            } else {
                reorderBar.classList.add('opacity-0', 'pointer-events-none');
            }

            // Only update gamification display if userName is set
            if (userName) {
                updateGamificationDisplay();
            }
        }

        /**
         * Updates the DOM for a given task list to reflect the current tasks.
         * @param {HTMLElement} container - The DOM element representing the task list container.
         * @param {Array<object>} newTasks - The array of task objects to be rendered.
         * @param {boolean} isEmptyMessageNeeded - True if an "empty list" message should be shown.
         * @param {string} emptyMessageText - The text for the "empty list" message.
         * @param {boolean} [inReorderMode=false] - True if currently in reordering mode.
         * @param {string|null} [reorderingTaskId=null] - The ID of the task being reordered.
         * @param {string|null} [focusTaskId=null] - The ID of the task to focus/scroll to.
         */
        function updateTaskListDOM(container, newTasks, isEmptyMessageNeeded, emptyMessageText, inReorderMode = false, reorderingTaskId = null, focusTaskId = null) {
            const existingElements = Array.from(container.children).filter(child => child.classList.contains('task-item'));
            const existingIds = new Set(existingElements.map(el => el.dataset.id));
            const newIds = new Set(newTasks.map(task => task.id));

            // Remove elements that are no longer in the newTasks array
            existingElements.forEach(element => {
                if (!newIds.has(element.dataset.id)) {
                    element.style.transform = `translateX(-100vw)`;
                    element.style.opacity = '0';
                    element.addEventListener('transitionend', () => {
                        element.remove();
                    }, { once: true });
                }
            });

            const fragment = document.createDocumentFragment();
            newTasks.forEach(task => {
                let taskElement = container.querySelector(`[data-id="${task.id}"]`);
                if (taskElement) {
                    // Update existing element (e.e.g., for completion status change, pin status)
                    const newElement = createTaskElement(task, false, inReorderMode, reorderingTaskId); // Create a new element to get updated classes
                    taskElement.className = newElement.className; // Update classes
                    // Only update checkbox if it exists in the new element (i.e., not a note)
                    const newCheckbox = newElement.querySelector('input[type="checkbox"]');
                    const existingCheckbox = taskElement.querySelector('input[type="checkbox"]');
                    if (newCheckbox && existingCheckbox) {
                        existingCheckbox.checked = task.completed;
                    } else if (!newCheckbox && existingCheckbox) {
                        // If it was a task and now it's a note, remove the checkbox
                        existingCheckbox.remove();
                    } else if (newCheckbox && !existingCheckbox) {
                        // If it was a note and now it's a task, add the checkbox
                        taskElement.querySelector('.flex-grow').prepend(newCheckbox);
                    }

                    taskElement.querySelector('.task-name').textContent = task.name;
                    taskElement.querySelector('.task-name-wrapper').innerHTML = newElement.querySelector('.task-name-wrapper').innerHTML; // Update pin/note icon
                    taskElement.querySelector('.task-importance-display').className = newElement.querySelector('.task-importance-display').className;
                    taskElement.querySelector('.task-importance-display').textContent = newElement.querySelector('.task-importance-display').textContent;
                    // Update action buttons based on reorder mode
                    const existingActionButtons = taskElement.querySelector('.flex.items-center.space-x-2.space-x-reverse.mr-2');
                    if (existingActionButtons) {
                        existingActionButtons.innerHTML = newElement.querySelector('.flex.items-center.space-x-2.space-x-reverse.mr-2').innerHTML;
                    }
                } else {
                    // Add new element
                    taskElement = createTaskElement(task, true, inReorderMode, reorderingTaskId); // Pass true for new task animation
                }
                fragment.appendChild(taskElement);
            });

            // Clear container and append fragment (this will cause reflow and trigger transitions)
            container.innerHTML = '';
            container.appendChild(fragment);

            // Handle empty message
            const existingNoMessage = container.querySelector('#dynamicNoActiveMessage, #dynamicNoCompletedMessage');
            if (isEmptyMessageNeeded) {
                if (!existingNoMessage) {
                    const noItem = document.createElement('div');
                    noItem.id = container.id === 'activeTaskList' ? 'dynamicNoActiveMessage' : 'dynamicNoCompletedMessage';
                    noItem.className = 'text-gray-500 dark:text-gray-400 text-center py-4';
                    noItem.textContent = emptyMessageText;
                    container.appendChild(noItem);
                }
            } else {
                if (existingNoMessage) {
                    existingNoMessage.remove();
                }
            }

            // Apply highlight and scroll for the focused task
            if (focusTaskId) {
                const taskElement = document.querySelector(`.task-item[data-id="${focusTaskId}"]`);
                if (taskElement) {
                    taskElement.classList.add('highlight');
                    taskElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    setTimeout(() => {
                        taskElement.classList.remove('highlight');
                    }, 1500); // Remove highlight after animation
                }
            } else if (!inReorderMode && newTasks.length > 0) {
                // For page navigation or general re-render, scroll to the first item of the current page
                const firstTaskElement = container.querySelector(`.task-item[data-id="${newTasks[0].id}"]`);
                if (firstTaskElement) {
                    firstTaskElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }
            }
        }


        /**
         * Renders pagination controls for a given task list.
         * @param {HTMLElement} containerElement The DOM element to render controls into.
         * @param {number} totalItems The total number of items in the list.
         * @param {number} currentPage The current page number.
         * @param {'active'|'completed'} listType The type of list ('active' or 'completed').
         */
        function renderPaginationControls(containerElement, totalItems, currentPage, listType) {
            const totalPages = Math.ceil(totalItems / TASKS_PER_PAGE);
            const maxPageButtons = 3; // Max number of page buttons to show (excluding prev/next and ellipses)

            if (totalPages <= 1) {
                containerElement.classList.add('hidden');
                containerElement.innerHTML = '';
                return;
            } else {
                if (listType === 'completed' && completedTasksSection.classList.contains('hidden')) {
                    containerElement.classList.add('hidden');
                    containerElement.innerHTML = '';
                    return;
                }
                containerElement.classList.remove('hidden');
            }

            containerElement.innerHTML = '';
            containerElement.classList.add('flex', 'flex-wrap', 'justify-center', 'items-center', 'gap-2', 'my-4'); // Added flex-wrap and gap

            // Previous button
            const prevBtn = document.createElement('button');
            prevBtn.className = `p-1 rounded-full bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 text-gray-800 dark:text-gray-100 transition duration-300 ease-in-out focus:outline-none focus:ring-2 focus:ring-blue-400 ${currentPage === 1 ? 'opacity-50 cursor-not-allowed' : ''}`;
            prevBtn.innerHTML = `<svg class="h-5 w-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path></svg>`;
            prevBtn.disabled = currentPage === 1;
            prevBtn.title = "صفحه قبلی";
            prevBtn.addEventListener('click', () => {
                if (listType === 'active') {
                    activeCurrentPage = Math.max(1, activeCurrentPage - 1);
                } else {
                    completedCurrentPage = Math.max(1, completedCurrentPage - 1);
                }
                renderTasks();
            });
            containerElement.appendChild(prevBtn);

            // Function to create a page button
            const createPageButton = (pageNumber, isActive = false) => {
                const button = document.createElement('button');
                button.className = `px-3 py-1 rounded-full text-sm font-semibold transition duration-200 ease-in-out
                                    ${isActive ? 'bg-blue-600 text-white dark:bg-blue-500' : 'bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 text-gray-800 dark:text-gray-100'}
                                    focus:outline-none focus:ring-2 focus:ring-blue-400`;
                button.textContent = pageNumber;
                button.title = `صفحه ${pageNumber}`;
                button.addEventListener('click', () => {
                    if (listType === 'active') {
                        activeCurrentPage = pageNumber;
                    } else {
                        completedCurrentPage = pageNumber;
                    }
                    renderTasks();
                });
                return button;
            };

            // Function to create an ellipsis
            const createEllipsis = () => {
                const span = document.createElement('span');
                span.className = 'px-2 py-1 text-gray-500 dark:text-gray-400';
                span.textContent = '...';
                return span;
            };

            let startPage, endPage;

            if (totalPages <= maxPageButtons) {
                // Show all pages if total pages are less than or equal to maxPageButtons
                startPage = 1;
                endPage = totalPages;
            } else {
                // Calculate start and end pages for the dynamic range
                const half = Math.floor(maxPageButtons / 2);
                startPage = currentPage - half;
                endPage = currentPage + half;

                if (startPage < 1) {
                    startPage = 1;
                    endPage = maxPageButtons;
                }
                if (endPage > totalPages) {
                    endPage = totalPages;
                    startPage = totalPages - maxPageButtons + 1;
                }
            }

            // Add first page button and ellipsis if needed
            if (startPage > 1) {
                containerElement.appendChild(createPageButton(1));
                if (startPage > 2) {
                    containerElement.appendChild(createEllipsis());
                }
            }

            // Add page buttons within the calculated range
            for (let i = startPage; i <= endPage; i++) {
                containerElement.appendChild(createPageButton(i, i === currentPage));
            }

            // Add ellipsis and last page button if needed
            if (endPage < totalPages) {
                if (endPage < totalPages - 1) {
                    containerElement.appendChild(createEllipsis());
                }
                containerElement.appendChild(createPageButton(totalPages));
            }

            // Next button
            const nextBtn = document.createElement('button');
            nextBtn.className = `p-1 rounded-full bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 text-gray-800 dark:text-gray-100 transition duration-300 ease-in-out focus:outline-none focus:ring-2 focus:ring-blue-400 ${currentPage === totalPages ? 'opacity-50 cursor-not-allowed' : ''}`;
            nextBtn.innerHTML = `<svg class="h-5 w-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path></svg>`;
            nextBtn.disabled = currentPage === totalPages;
            nextBtn.title = "صفحه بعدی";
            nextBtn.addEventListener('click', () => {
                if (listType === 'active') {
                    activeCurrentPage = Math.min(totalPages, activeCurrentPage + 1);
                } else {
                    completedCurrentPage = Math.min(totalPages, completedCurrentPage + 1);
                }
                renderTasks();
            });
            containerElement.appendChild(nextBtn);
        }

        // Function to render achievements into the Achievements Modal
        function renderAchievementsIntoModal() {
            achievementsModalBody.innerHTML = ''; // Clear existing achievements

            const achievedList = [];
            const unachievedList = [];

            // Populate achieved and unachieved lists
            achievementsData.forEach(achievement => {
                let isAchieved = false;
                // Calculate current counts for achievements
                const currentTotalTasksCompleted = tasks.filter(task => task.completed).length;
                const currentImportantTasksCompleted = tasks.filter(task => task.completed && task.importance === 'important').length; // Kept for importantTasks achievements if they were not removed from the data
                const currentCustomTasksCompleted = totalCustomTasksCompleted; // Direct use of counter

                if (achievement.type === 'level') {
                    const levelInfo = levelPointsThresholds.find(l => l.name === achievement.name);
                    if (levelInfo && zPoint >= levelInfo.points) {
                        isAchieved = true;
                    }
                } else if (achievement.type === 'streak') {
                    if (dailyStreak >= achievement.value) {
                        isAchieved = true;
                    }
                } else if (achievement.type === 'totalTasks') {
                    if (currentTotalTasksCompleted >= achievement.value) {
                        isAchieved = true;
                    }
                } else if (achievement.type === 'importantTasks') {
                    if (currentImportantTasksCompleted >= achievement.value) {
                        isAchieved = true;
                    }
                } else if (achievement.type === 'customTasks') {
                    if (currentCustomTasksCompleted >= achievement.value) {
                        isAchieved = true;
                    }
                } else if (achievement.type === 'points') {
                    if (zPoint >= achievement.value) {
                        isAchieved = true;
                    }
                } else if (achievement.type === 'firstPin') {
                    if (hasPinnedTaskEver) {
                        isAchieved = true;
                    }
                }

                if (isAchieved) {
                    achievedList.push({ ...achievement, unlockedDate: achievementUnlockDates[achievement.name] });
                } else {
                    unachievedList.push(achievement);
                }
            });

            // Sort achieved list by unlocked date (newest first)
            achievedList.sort((a, b) => {
                const dateA = new Date(a.unlockedDate || 0);
                const dateB = new Date(b.unlockedDate || 0);
                return dateB.getTime() - dateA.getTime(); // Newest to oldest
            });

            // Sort unachieved list (levels first, then by value/level)
            unachievedList.sort((a, b) => {
                if (a.type === 'level' && b.type !== 'level') return -1;
                if (a.type !== 'level' && b.type === 'level') return 1;
                if (a.type === 'level' && b.type === 'level') return a.level - b.level;
                return (a.value || 0) - (b.value || 0); // Sort other types by value
            });

            const sortedAchievements = [...achievedList, ...unachievedList];

            if (sortedAchievements.length === 0) {
                const noAchievementsMessage = document.createElement('p');
                noAchievementsMessage.className = 'text-gray-500 dark:text-gray-400 text-center col-span-full py-4';
                noAchievementsMessage.textContent = 'هنوز دستاوردی کسب نشده است.';
                achievementsModalBody.appendChild(noAchievementsMessage);
            } else {
                sortedAchievements.forEach(achievement => {
                    const achievementItem = document.createElement('div');
                    const isAchieved = unlockedAchievements.includes(achievement.name);

                    achievementItem.className = `achievement-item-card ${isAchieved ? '' : 'unachieved'}`;

                    // Add icon based on achievement status
                    achievementItem.innerHTML = `
                        <i class="${isAchieved ? achievement.icon : 'fa-solid fa-lock'} icon"></i>
                        <span class="name">${achievement.name}</span>
                        `;

                    // Add click listener to show details only for achieved items
                     if (isAchieved) {
                        achievementItem.addEventListener('click', () => {
                            if (achievement.type === 'level') {
                                // اگر نوع دستاورد 'level' باشد، اطلاعات سطح را ارسال کنید
                                showDetailModal(achievement.type, achievement.name); // Pass name for level
                            } else {
                                // در غیر این صورت، اطلاعات دستاورد را ارسال کنید
                                showDetailModal('achievement', achievement.name);
                            }
                        });
                    }

                    achievementsModalBody.appendChild(achievementItem);
                });
            }
        }

        // Add task
        addTaskBtn.addEventListener('click', () => {
            const taskName = taskInput.value.trim();
            const importance = importanceSelect.value;
            let customPoints = 0;

            if (taskName.length === 0) {
                showMessageBox('لطفاً نام وظیفه را وارد کنید.', 'info');
                return;
            }

            // Check max length based on importance
            const currentMaxLength = importance === 'note' ? NOTE_TASK_MAXLENGTH : DEFAULT_TASK_MAXLENGTH;
            if (taskName.length > currentMaxLength) {
                showMessageBox(`مقدار ورودی نباید بیش از ${currentMaxLength} کاراکتر باشد.`, 'error');
                return;
            }

            if (importance === 'custom') {
                // Convert Persian numbers to English before parsing
                const convertedPoints = convertPersianNumbersToEnglish(customPointsInput.value);
                customPoints = parseInt(convertedPoints, 10);
                if (isNaN(customPoints) || customPoints <= 0 || customPoints > MAX_CUSTOM_POINTS) {
                    showMessageBox(`لطفاً یک مقدار پوینت سفارشی معتبر (حداکثر ${MAX_CUSTOM_POINTS}) وارد کنید.`, 'info');
                    return;
                }
            }

            const newTask = {
                id: Date.now().toString(), // Unique ID for task
                name: taskName,
                completed: false, // Notes are never "completed" in the gamification sense
                importance: importance,
                customPoints: importance === 'custom' ? customPoints : undefined, // Store custom points if importance is custom
                isPinned: false, // New property for pinning
                pinnedAt: null // Timestamp for when it was pinned
            };
            tasks.push(newTask);
            taskInput.value = ''; // Clear input
            customPointsInput.value = ''; // Clear custom points input
            importanceSelect.value = 'normal'; // Reset importance selection
            customPointsInput.classList.add('hidden'); // Hide custom points input
            taskInput.setAttribute('maxlength', DEFAULT_TASK_MAXLENGTH); // Reset max length
            saveToLocalStorage(); // Save after adding
            renderTasks(newTask.id); // Re-render tasks after adding and focus on the new task
            showMessageBox('وظیفه جدید با موفقیت اضافه شد!', 'success');
        });

        // Toggle display of completed tasks section
        toggleCompletedTasksBtn.addEventListener('click', () => {
            completedTasksSection.classList.toggle('hidden');
            toggleIcon.classList.toggle('rotate-180'); // Rotate arrow icon
            // Re-render pagination controls to update visibility based on section status
            renderPaginationControls(completedTasksPagination, tasks.filter(task => task.completed).length, completedCurrentPage, 'completed');
        });

        // Manage task actions (toggle completion, delete, edit, save, cancel)
        // Main handler for clicks on task items
        function handleTaskClick(e) {
            const taskItemElement = e.target.closest('.task-item');
            if (!taskItemElement) return;

            const taskId = taskItemElement.dataset.id;
            const target = e.target;
            const task = tasks.find(t => t.id === taskId);

            // If in reordering mode, only allow clicks on the move-up/move-down buttons for the active task
            if (isReorderingMode) {
                if (taskId === reorderingTaskId) {
                    const action = target.closest('button')?.dataset.action;
                    if (action === 'move-up') {
                        moveTask(taskId, 'up');
                    }
                    else if (action === 'move-down') {
                        moveTask(taskId, 'down');
                    }
                }
                e.preventDefault(); // Prevent default click action on other elements when in reordering mode
                return;
            }

            // If it's a 'note' task, prevent completion logic and notifications on click
            if (task && task.importance === 'note') {
                const isMenuButton = target.closest('.three-dot-menu-btn');
                if (!isMenuButton) { // If not clicking the menu button, do nothing
                    e.preventDefault();
                    return;
                }
            }

            // Normal mode logic
            const isCheckbox = (target.tagName === 'INPUT' && target.type === 'checkbox');
            const isMenuButton = target.closest('.three-dot-menu-btn');
            const action = target.closest('button')?.dataset.action;

            if (isCheckbox) {
                toggleTaskCompletion(taskId, taskItemElement);
            } else if (isMenuButton) {
                if (task) {
                    showTaskActionsMenu(taskId, isMenuButton, task.completed);
                }
            } else if (action === 'pin-task' || action === 'unpin-task') { // These actions are from the menu, but if somehow clicked directly
                pinTask(taskId);
            } else {
                // This is the click on the task card itself (not checkbox or menu button)
                // Only toggle completion if it.importance !== 'note'
                if (task && task.importance !== 'note') {
                    toggleTaskCompletion(taskId, taskItemElement);
                }
            }
        }

        // Add event listener to activeTaskList and completedTasksContainer for delegation
        activeTaskList.addEventListener('click', handleTaskClick);
        completedTasksContainer.addEventListener('click', handleTaskClick);


        function toggleTaskCompletion(taskId, taskItemElement) {
            const taskIndex = tasks.findIndex(t => t.id === taskId);
            if (taskIndex > -1) {
                const task = tasks[taskIndex];

                // If it's a note, do nothing
                if (task.importance === 'note') {
                    return;
                }

                let pointsGained = 0;
                let focusAfterRender = null; // Initialize focus target

                if (!task.completed) { // User wants to complete the task
                    task.completed = true;
                    task.isPinned = false; // Unpin task when completed
                    task.pinnedAt = null; // Clear pinnedAt timestamp
                    if (task.importance === 'important') {
                        pointsGained = pointsPerImportantTask;
                    } else if (task.importance === 'normal') {
                        pointsGained = pointsPerNormalTask;
                    }
                    else if (task.importance === 'custom' && task.customPoints) {
                        pointsGained = task.customPoints;
                        totalCustomTasksCompleted++; // Increment custom tasks counter
                    }
                    zPoint += pointsGained;
                    showMessageBox('وظیفه تکمیل شد!', 'success');
                    showPointsGainFeedback(pointsGained, taskItemElement); // Show animation for all completed tasks

                    // Daily streak logic (only on completion)
                    const today = new Date().toDateString();

                    if (!lastCompletionDate) {
                        dailyStreak = 1;
                        showMessageBox('زنجیره روزانه شما آغاز شد!', 'info');
                    } else {
                        const lastDate = new Date(lastCompletionDate);
                        const yesterday = new Date();
                        yesterday.setDate(yesterday.getDate() - 1);

                        if (lastDate.toDateString() === yesterday.toDateString()) {
                            dailyStreak++;
                            showMessageBox(`زنجیره: ${dailyStreak} روز متوالی!`, 'info');
                        } else if (lastDate.toDateString() !== today) {
                            dailyStreak = 1; // Reset if not consecutive and today hasn't been completed yet
                            showMessageBox('زنجیره روزانه شما بازنشانی و مجدداً آغاز شد.', 'info');
                        }
                    }
                    lastCompletionDate = today;
                    highestDailyStreak = Math.max(highestDailyStreak, dailyStreak); // Update highest streak

                    // Re-sort tasks so completed ones are at the end
                    tasks.sort((a, b) => (a.completed === b.completed) ? 0 : a.completed ? 1 : -1);

                    focusAfterRender = task.id; // Focus on the task in its new (completed) location

                } else { // User clicked on a completed task, meaning they want to create a new active instance and delete the original completed one
                    // Deduct points for a task being "uncompleted" (removed from completed list)
                    let pointsDeducted = 0;
                    if (task.importance === 'important') {
                        pointsDeducted = pointsPerImportantTask;
                    } else if (task.importance === 'normal') {
                        pointsDeducted = pointsPerNormalTask;
                    } else if (task.importance === 'custom' && task.customPoints) {
                        pointsDeducted = task.customPoints;
                        totalCustomTasksCompleted--; // Decrement custom tasks counter
                    }
                    zPoint -= pointsDeducted; // Deduct points
                    if (zPoint < 0) zPoint = 0; // Ensure points don't go negative

                    // Create a new task based on the completed one
                    const newActiveTask = {
                        id: Date.now().toString(), // New unique ID
                        name: task.name,
                        completed: false, // This new instance is active
                        importance: task.importance,
                        customPoints: task.customPoints,
                        isPinned: false, // New tasks are not pinned by default
                        pinnedAt: null // New tasks are not pinned, so no timestamp
                    };

                    tasks.push(newActiveTask); // Add new active task to the end of the tasks array
                    focusAfterRender = newActiveTask.id; // Set focus target to the new task

                    // Now, remove the original completed task from the array
                    tasks.splice(taskIndex, 1); // Remove the original completed task

                    showMessageBox(`وظیفه بازنشانی شد!`, 'success');
                }
                saveToLocalStorage();
                renderTasks(focusAfterRender); // Pass the focus target
            }
        }

        // Function to toggle the pinned status of a task
        function pinTask(taskId) {
            const taskIndex = tasks.findIndex(t => t.id === taskId);
            if (taskIndex > -1) {
                const task = tasks[taskIndex];
                task.isPinned = !task.isPinned; // Toggle pin status

                if (task.isPinned) {
                    task.pinnedAt = new Date().toISOString(); // Set timestamp when pinned
                    if (!hasPinnedTaskEver) {
                        hasPinnedTaskEver = true; // Set flag if this is the first time pinning
                    }
                } else {
                    task.pinnedAt = null; // Clear timestamp when unpinned
                }

                saveToLocalStorage();
                renderTasks(taskId); // Re-render and focus on the pinned/unpinned task
                // Use truncateText for the task name in the message
                showMessageBox(`وظیفه "${truncateText(task.name, 15)}" ${task.isPinned ? 'پین شد!' : 'از پین خارج شد.'}`, 'info');
            }
        }


        // Function to show the three-dot menu popup
        function showTaskActionsMenu(taskId, buttonElement, isCompletedTask) {
            // Close any existing menus
            document.querySelectorAll('.task-action-menu').forEach(menu => menu.remove());

            // If in reordering mode, do not show menu for other tasks
            if (isReorderingMode) {
                return;
            }

            const menu = document.createElement('div');
            menu.className = 'task-action-menu';
            menu.style.position = 'absolute';
            menu.style.zIndex = '100';
            menu.style.visibility = 'hidden'; // Hide initially to get dimensions

            document.body.appendChild(menu); // Append to body to get actual width

            const task = tasks.find(t => t.id === taskId);
            let menuHtml = ``;
            if (isCompletedTask) {
                menuHtml = `
                    <button data-action="copy-task">
                        <i class="fa-solid fa-copy ml-2"></i>
                        کپی
                    </button>
                    <button data-action="delete-task">
                        <i class="fa-solid fa-trash-can ml-2"></i>
                        حذف
                    </button>
                `;
            } else {
                menuHtml = `
                    <button data-action="edit-task">
                        <i class="fa-solid fa-pen ml-2"></i>
                        ویرایش
                    </button>
                    <button data-action="activate-reorder" data-task-id="${taskId}">
                        <i class="fa-solid fa-arrows-up-down ml-2"></i>
                        تغییر چیدمان
                    </button>
                    <button data-action="${task.isPinned ? 'unpin-task' : 'pin-task'}">
                        <i class="fa-solid fa-thumbtack ml-2 ${task.isPinned ? 'fa-rotate-90' : ''}"></i>
                        ${task.isPinned ? 'برداشتن پین' : 'پین کردن'}
                    </button>
                    <button data-action="delete-task">
                        <i class="fa-solid fa-trash-can ml-2"></i>
                        حذف
                    </button>
                `;
            }
            menu.innerHTML = menuHtml;

            // Dynamic positioning
            const rect = buttonElement.getBoundingClientRect();
            const padding = 5; // Small padding from screen edges

            // Calculate initial top and left based on button position
            let menuTop = rect.bottom + window.scrollY + 5;
            let menuLeft = rect.left + window.scrollX;

            // Adjust if menu goes off right side of screen (in RTL context, right edge matters more)
            if (menuLeft + menu.offsetWidth > window.innerWidth - padding) {
                menuLeft = window.innerWidth - menu.offsetWidth - padding;
            }
            // Adjust if menu goes off left side of screen
            if (menuLeft < padding) {
                menuLeft = padding;
            }

            // Adjust if menu goes off bottom of screen
            if (menuTop + menu.offsetHeight > window.innerHeight + window.scrollY - padding) {
                menuTop = rect.top + window.scrollY - menu.offsetHeight - 5;
                if (menuTop < padding + window.scrollY) { // If still off top, place at top with padding
                    menuTop = padding + window.scrollY;
                }
            }

            menu.style.top = `${menuTop}px`;
            menu.style.left = `${menuLeft}px`;
            menu.style.visibility = 'visible'; // Make visible

            // Event listener for menu actions
            menu.addEventListener('click', (e) => {
                const action = e.target.closest('button')?.dataset.action;
                if (action) {
                    menu.remove(); // Close menu after action
                    document.removeEventListener('click', closeMenu); // Remove global listener
                    if (action === 'edit-task') {
                        showEditTaskModal(taskId);
                    }
                    else if (action === 'activate-reorder') {
                        activateReorderMode(taskId);
                    } else if (action === 'delete-task') {
                        deleteTask(taskId);
                    } else if (action === 'copy-task') {
                        copyTask(taskId);
                    } else if (action === 'pin-task' || action === 'unpin-task') {
                        pinTask(taskId);
                    }
                }
            });

            // Close menu when clicking outside
            const closeMenu = (e) => {
                // Check if the click was outside the menu and outside the button that opened it
                // Use closest for more robust detection of interactive elements
                const isInteractiveElement = e.target.closest('input, select, button, [type="checkbox"]');

                if (!menu.contains(e.target) && !buttonElement.contains(e.target) && !isInteractiveElement) {
                    menu.remove();
                    document.removeEventListener('click', closeMenu);
                    console.log('Clicked outside menu, closing');
                } else if (isInteractiveElement && !menu.contains(e.target)) {
                    // If an interactive element outside the menu was clicked, close the menu, but allow the element's action.
                    menu.remove();
                    document.removeEventListener('click', closeMenu);
                    console.log('Clicked on interactive element outside menu, closing');
                }
            };
            // Add a small delay to allow the menu to render before attaching the global click listener
            // This prevents the menu from closing immediately by the initial click that opened it.
            setTimeout(() => {
                document.addEventListener('click', closeMenu);
            }, 50);
        }

        // Function to activate reordering mode
        function activateReorderMode(taskId) {
            isReorderingMode = true;
            reorderingTaskId = taskId;
            // Hide all other task action menus
            document.querySelectorAll('.task-action-menu').forEach(menu => menu.remove());
            renderTasks(taskId); // Re-render to show arrows and disable other items, focus on the reordering task
        }

        // Function to deactivate reorder mode
        function deactivateReorderMode() {
            isReorderingMode = false;
            reorderingTaskId = null;
            renderTasks(); // Re-render to revert to normal display
            showMessageBox('چیدمان وظیفه با موفقیت تغییر کرد!', 'success'); // Show message only on finish
        }

        // Event listener for the "Done Reordering" button (now the finishReorderBtn in the floating bar)
        finishReorderBtn.addEventListener('click', deactivateReorderMode);

        // Function to move a task up or down
        function moveTask(taskId, direction) {
            const activeTasks = tasks.filter(task => !task.completed);
            const taskIndexInActive = activeTasks.findIndex(task => task.id === taskId);

            if (taskIndexInActive === -1) {
                showMessageBox('خطا: وظیفه برای جابجایی یافت نشد.', 'error');
                return;
            }

            const newIndex = direction === 'up' ? taskIndexInActive - 1 : taskIndexInActive + 1;

            if (newIndex < 0 || newIndex >= activeTasks.length) {
                showMessageBox('نمی‌توان وظیفه را بیشتر جابجا کرد.', 'info');
                return;
            }

            // Perform the swap
            const [movedTask] = activeTasks.splice(taskIndexInActive, 1);
            activeTasks.splice(newIndex, 0, movedTask);

            // If the task was pinned, unpin it when manually reordering
            if (movedTask.isPinned) {
                movedTask.isPinned = false;
                movedTask.pinnedAt = null; // Clear pinnedAt timestamp
                showMessageBox('وظیفه به دلیل تغییر چیدمان دستی از پین خارج شد.', 'info');
            }

            // Reconstruct the main tasks array
            const completedTasks = tasks.filter(task => task.completed);
            tasks = [...activeTasks, ...completedTasks];

            // Find the new index of the moved task in the *full* active tasks list
            const updatedActiveTasks = tasks.filter(task => !task.completed);
            const newIndexInActiveList = updatedActiveTasks.findIndex(task => task.id === taskId);

            // Calculate the new page based on the new index
            const newPage = Math.ceil((newIndexInActiveList + 1) / TASKS_PER_PAGE);
            if (newPage !== activeCurrentPage) {
                activeCurrentPage = newPage;
            }

            saveToLocalStorage();
            renderTasks(taskId); // Re-render to show new order and potentially new page, focusing on the moved task
        }


        // Function to show edit task modal
        function showEditTaskModal(taskId) {
            currentTaskBeingEditedId = taskId;
            const task = tasks.find(t => t.id === taskId);
            if (!task) {
                showMessageBox('خطا: وظیفه برای ویرایش یافت نشد.', 'error');
                return;
            }

            editTaskNameInput.value = task.name;
            editTaskImportanceSelect.value = task.importance;

            // Set initial maxlength based on task importance
            editTaskNameInput.setAttribute('maxlength', task.importance === 'note' ? NOTE_TASK_MAXLENGTH : DEFAULT_TASK_MAXLENGTH);

            if (task.importance === 'custom') {
                editTaskCustomPointsInput.classList.remove('hidden');
                editTaskCustomPointsInput.value = task.customPoints || '';
                editTaskCustomPointsInput.focus(); // Auto-focus when custom is selected
            } else {
                editTaskCustomPointsInput.classList.add('hidden');
                editTaskCustomPointsInput.value = ''; // Clear value if hidden
            }

            // Remove previous onchange handler if exists
            editTaskImportanceSelect.onchange = null;
            // Add new event listeners for editTaskImportanceSelect
            editTaskImportanceSelect.addEventListener('change', handleEditTaskImportanceChange);

            editTaskModal.classList.remove('hidden'); // Ensure modal is not hidden before showing
            void editTaskModal.offsetWidth; // Force reflow
            editTaskModal.classList.add('show');
            editTaskNameInput.focus();
        }

        // Handler for importanceSelect change event (for add task section)
        importanceSelect.addEventListener('change', () => {
            const selectedImportance = importanceSelect.value;
            if (selectedImportance === 'custom') {
                customPointsInput.classList.remove('hidden');
                customPointsInput.focus();
                taskInput.setAttribute('maxlength', DEFAULT_TASK_MAXLENGTH); // Keep default for custom
            } else if (selectedImportance === 'note') {
                customPointsInput.classList.add('hidden');
                customPointsInput.value = '';
                taskInput.setAttribute('maxlength', NOTE_TASK_MAXLENGTH); // Set to 150 for note
            } else {
                customPointsInput.classList.add('hidden');
                customPointsInput.value = ''; // Clear value if hidden
                taskInput.setAttribute('maxlength', DEFAULT_TASK_MAXLENGTH); // Reset to 30 for other types
            }
        });

        // Handler for editTaskImportanceSelect change event (for edit task modal)
        function handleEditTaskImportanceChange() {
            const selectedImportance = editTaskImportanceSelect.value;
            if (selectedImportance === 'custom') {
                editTaskCustomPointsInput.classList.remove('hidden');
                editTaskCustomPointsInput.focus();
                editTaskNameInput.setAttribute('maxlength', DEFAULT_TASK_MAXLENGTH); // Keep default for custom
            } else if (selectedImportance === 'note') {
                editTaskCustomPointsInput.classList.add('hidden');
                editTaskCustomPointsInput.value = '';
                editTaskNameInput.setAttribute('maxlength', NOTE_TASK_MAXLENGTH); // Set to 150 for note
            } else {
                editTaskCustomPointsInput.classList.add('hidden');
                editTaskCustomPointsInput.value = ''; // Clear value if hidden
                editTaskNameInput.setAttribute('maxlength', DEFAULT_TASK_MAXLENGTH); // Reset to 30 for other types
            }
        }

        // Save edited task
        function saveEditedTask() {
            const taskId = currentTaskBeingEditedId;
            const newTaskName = editTaskNameInput.value.trim();
            const newImportance = editTaskImportanceSelect.value;
            let newCustomPoints = undefined;

            if (newTaskName.length === 0) {
                showMessageBox('نام وظیفه نمی‌تواند خالی باشد.', 'info');
                return;
            }

            // Check max length based on new importance
            const currentMaxLength = newImportance === 'note' ? NOTE_TASK_MAXLENGTH : DEFAULT_TASK_MAXLENGTH;
            if (newTaskName.length > currentMaxLength) {
                showMessageBox(`مقدار ورودی نباید بیش از ${currentMaxLength} کاراکتر باشد.`, 'error');
                return;
            }

            if (newImportance === 'custom') {
                // Convert Persian numbers to English before parsing
                const convertedPoints = convertPersianNumbersToEnglish(editTaskCustomPointsInput.value);
                newCustomPoints = parseInt(convertedPoints, 10);
                if (isNaN(newCustomPoints) || newCustomPoints <= 0 || newCustomPoints > MAX_CUSTOM_POINTS) {
                    showMessageBox(`لطفاً یک مقدار پوینت سفارشی معتبر (حداکثر ${MAX_CUSTOM_POINTS}) وارد کنید.`, 'info');
                    return;
                }
            }

            const taskIndex = tasks.findIndex(t => t.id === taskId);
            if (taskIndex > -1) {
                tasks[taskIndex].name = newTaskName;
                tasks[taskIndex].importance = newImportance;
                tasks[taskIndex].customPoints = newCustomPoints;
                // If changing a note to a task, or vice versa, reset completion status
                if (tasks[taskIndex].importance === 'note' && tasks[taskIndex].completed) {
                    tasks[taskIndex].completed = false; // A note cannot be completed
                } else if (tasks[taskIndex].importance !== 'note' && tasks[taskIndex].completed) {
                    // If a task was completed and now it's not a note, keep it completed (or handle as per original logic)
                    // For simplicity, if it was completed, it remains completed unless it becomes a note.
                    // The logic for re-activating a completed task is handled by clicking it directly.
                }

                saveToLocalStorage();
                renderTasks(taskId); // Re-render and focus on the edited task
                showMessageBox('وظیفه با موفقیت ویرایش شد!', 'success');
                editTaskModal.classList.remove('show');
                setTimeout(() => { // Add delay for hiding after transition
                    editTaskModal.classList.add('hidden');
                }, 50);
            } else {
                showMessageBox('خطا: وظیفه برای ویرایش یافت نشد.', 'error');
            }
        }

        saveEditedTaskBtn.addEventListener('click', saveEditedTask);


        // Cancel task edit
        cancelEditTaskBtn.addEventListener('click', () => {
            editTaskModal.classList.remove('show');
            setTimeout(() => { // Add delay for hiding after transition
                editTaskModal.classList.add('hidden');
            }, 50);
            showMessageBox('ویرایش وظیفه لغو شد.', 'info');
        });

        // Function to delete task (called from menu)
        function deleteTask(taskId) {
            const taskIndex = tasks.findIndex(t => t.id === taskId);
            if (taskIndex > -1) {
                const taskItemElement = document.querySelector(`.task-item[data-id="${taskId}"]`);
                const taskToDelete = tasks[taskIndex];
                taskToDelete.isPinned = false; // Unpin task when deleting
                taskToDelete.pinnedAt = null; // Clear pinnedAt timestamp

                // Create a copy of the task with its original index for undo
                const deletedTaskCopy = { ...taskToDelete, originalIndex: taskIndex };

                tasks.splice(taskIndex, 1); // Remove task
                saveToLocalStorage();

                // Delete animation
                if (taskItemElement) {
                    taskItemElement.style.transform = `translateX(-100vw)`;
                    taskItemElement.style.opacity = '0';
                    taskItemElement.addEventListener('transitionend', () => {
                        renderTasks(); // Re-render after animation
                        // Use showMessageBox for undo message, truncate text
                        showMessageBox(`وظیفه "${truncateText(deletedTaskCopy.name, 15)}" حذف شد. برای بازگردانی ضربه بزنید.`, 'info', {
                            position: 'bottom-center',
                            isUndo: true,
                            duration: 5000,
                            taskData: deletedTaskCopy // Pass specific task data for undo
                        });
                    }, { once: true });
                } else {
                    // If element not found, still delete from data and re-render
                    renderTasks();
                    showMessageBox(`وظیفه "${truncateText(deletedTaskCopy.name, 15)}" حذف شد. برای بازگردانی ضربه بزنید.`, 'info', {
                        position: 'bottom-center',
                        isUndo: true,
                        duration: 5000,
                        taskData: deletedTaskCopy // Pass specific task data for undo
                        });
                }
            } else {
                showMessageBox('خطا: وظیفه برای حذف یافت نشد.', 'error');
            }
        }

        // Function to copy task (for completed tasks)
        function copyTask(taskId) {
            const originalTask = tasks.find(t => t.id === taskId);
            if (originalTask) {
                const newTask = {
                    id: Date.now().toString(), // New unique ID
                    name: originalTask.name,
                    completed: false, // Always active
                    importance: originalTask.importance,
                    customPoints: originalTask.customPoints, // Retain original custom points
                    isPinned: false, // New task is not pinned by default
                    pinnedAt: null // New task is not pinned, so no timestamp
                };
                tasks.push(newTask); // Add to end of list
                saveToLocalStorage();
                renderTasks(newTask.id); // Re-render and focus on the new copied task
                showMessageBox(`وظیفه "${truncateText(newTask.name, 15)}" به وظایف فعال کپی شد!`, 'success');
            } else {
                showMessageBox('خطا: وظیفه اصلی برای کپی یافت نشد.', 'error');
            }
        }

        // Function to undo a specific deletion
        function undoLastDeletion(taskToRestore) {
            if (taskToRestore) {
                // Find correct position to re-insert task
                // If originalIndex is valid and within bounds, try to insert there.
                // Otherwise, add to the end of active tasks.
                let insertIndex = tasks.length; // Default to end
                if (taskToRestore.originalIndex !== undefined && taskToRestore.originalIndex <= tasks.length) {
                    insertIndex = taskToRestore.originalIndex;
                }

                // Ensure task does not already exist (e.g., if undo clicked twice quickly)
                if (!tasks.some(t => t.id === taskToRestore.id)) {
                    tasks.splice(insertIndex, 0, taskToRestore);
                    saveToLocalStorage();
                    renderTasks(taskToRestore.id); // Re-render and focus on the restored task
                    showMessageBox(`وظیفه "${truncateText(taskToRestore.name, 15)}" بازگردانی شد.`, 'info');
                } else {
                    console.warn(`Task with ID ${taskToRestore.id} already exists, not re-adding.`);
                }
            }
        }


        // --- Theme Toggle Logic ---
        // Removed themeToggleBtn.addEventListener('click', ...)

        function applyTheme(theme) {
            const htmlElement = document.documentElement;
            if (theme === 'dark') {
                htmlElement.classList.add('dark');
                // Removed themeIcon.className update
            } else {
                htmlElement.classList.remove('dark');
                // Removed themeIcon.className update
            }
            // Re-apply level theme after overall light/dark mode change
            applyLevelTheme(level);
        }

        // Initialize theme on load and listen for system theme changes
        function initializeTheme() {
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme) {
                applyTheme(savedTheme);
            } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
                applyTheme('dark');
            } else {
                applyTheme('light');
            }

            // Listen for changes in system preferred color scheme
            window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
                const newSystemTheme = e.matches ? 'dark' : 'light';
                // Always apply system theme if no specific theme is saved by user
                applyTheme(newSystemTheme);
            });
        }

        // --- Menu and Modal Logic ---
        menuBtn.addEventListener('click', (e) => {
            e.stopPropagation(); // Prevent click propagation to window and closing dropdown

            // If points dropdown is open, close it
            if (!pointsDropdownContent.classList.contains('hidden')) {
                pointsDropdownContent.classList.remove('opacity-100', 'scale-y-100', 'is-open'); // Remove is-open
                pointsDropdownContent.classList.add('opacity-0', 'scale-y-95');
                dropdownIndicator.classList.remove('rotate-180');
                pointsDropdownToggle.classList.remove('is-open'); // Ensure toggle's corners reset
                pointsDropdownContent.addEventListener('transitionend', () => {
                    pointsDropdownContent.classList.add('hidden');
                }, { once: true });
            }

            menuDropdown.classList.toggle('hidden');
        });

        // Close dropdown when clicking outside
        window.addEventListener('click', (e) => {
            // Check if the click target is inside the menu button or the dropdown itself
            const isClickInsideMenu = menuBtn.contains(e.target) || menuDropdown.contains(e.target);
            // Check if the click target is an interactive element outside the menu/button (e.g., another checkbox, button)
            const isInteractiveElement = e.target.closest('input, select, button, [type="checkbox"]');

            // Close menu if clicked outside menu and its button,
            // AND if the click is not on another interactive element that should be allowed to function.
            // If it's an interactive element, we still want the menu to close, but the element's action to proceed.
            if (!isClickInsideMenu && !isInteractiveElement) {
                menuDropdown.classList.add('hidden');
                console.log('Clicked outside menu, closing');
            } else if (isInteractiveElement && !isClickInsideMenu) {
                // If an interactive element outside the menu was clicked, close the menu.
                menuDropdown.classList.add('hidden');
                console.log('Clicked on interactive element outside menu, closing');
            }
        });

        // Dropdown Toggle Logic for points dropdown (NEW)
        pointsDropdownToggle.addEventListener('click', (e) => {
            e.stopPropagation(); // Prevent click from bubbling up to window and closing immediately

            // If menu dropdown is open, close it
            if (!menuDropdown.classList.contains('hidden')) {
                menuDropdown.classList.add('hidden');
            }

            const isHidden = pointsDropdownContent.classList.contains('hidden');

            if (isHidden) {
                pointsDropdownContent.classList.remove('hidden');
                void pointsDropdownContent.offsetHeight; // Force reflow for animation
                pointsDropdownContent.classList.remove('opacity-0', 'scale-y-95');
                pointsDropdownContent.classList.add('opacity-100', 'scale-y-100', 'is-open'); // Add is-open
                dropdownIndicator.classList.add('rotate-180'); // Rotate arrow up
                pointsDropdownToggle.classList.add('is-open'); // Add is-open to toggle for corner change
            } else {
                pointsDropdownContent.classList.remove('opacity-100', 'scale-y-100', 'is-open'); // Remove is-open
                pointsDropdownContent.classList.add('opacity-0', 'scale-y-95');
                dropdownIndicator.classList.remove('rotate-180'); // Rotate arrow down
                pointsDropdownToggle.classList.remove('is-open'); // Remove is-open from toggle for corner change
                pointsDropdownContent.addEventListener('transitionend', () => {
                    pointsDropdownContent.classList.add('hidden');
                }, { once: true });
            }
        });

        // Close points dropdown when clicking outside (NEW)
        window.addEventListener('click', (e) => {
            if (!pointsDropdownToggle.contains(e.target) && !pointsDropdownContent.contains(e.target)) {
                if (!pointsDropdownContent.classList.contains('hidden')) {
                    pointsDropdownContent.classList.remove('opacity-100', 'scale-y-100', 'is-open'); // Remove is-open
                    pointsDropdownContent.classList.add('opacity-0', 'scale-y-95');
                    dropdownIndicator.classList.remove('rotate-180');
                    pointsDropdownToggle.classList.remove('is-open'); // Remove is-open from toggle for corner change
                    pointsDropdownContent.addEventListener('transitionend', () => {
                        pointsDropdownContent.classList.add('hidden');
                    }, { once: true });
                }
            }
        });


        profileMenuItem.addEventListener('click', (e) => {
            e.preventDefault();
            menuDropdown.classList.add('hidden'); // Hide dropdown

            // Show profile modal with animation
            profileModal.classList.remove('hidden');
            void profileModalContent.offsetWidth; // Force reflow
            profileModalContent.classList.remove('opacity-0', 'scale-95');
            profileModalContent.classList.add('opacity-100', 'scale-100');

            const totalTasks = tasks.length;
            const completedTasksCount = tasks.filter(task => task.completed).length;

            // Calculate days since creation
            let daysSinceCreation = 'نامشخص';
            if (userCreationDate) {
                const creationDate = new Date(userCreationDate);
                const today = new Date();
                const diffTime = Math.abs(today.getTime() - creationDate.getTime());
                daysSinceCreation = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
            }

            // Filter for achieved achievements and count them
            const achievedAchievementsCount = achievementsData.filter(achievement => {
                let isAchieved = false;
                const currentTotalTasksCompleted = tasks.filter(task => task.completed).length;

                if (achievement.type === 'level') {
                    const levelInfo = levelPointsThresholds.find(l => l.name === achievement.name);
                    if (levelInfo && zPoint >= levelInfo.points) {
                        isAchieved = true;
                    }
                } else if (achievement.type === 'streak') {
                    if (dailyStreak >= achievement.value) {
                        isAchieved = true;
                    }
                } else if (achievement.type === 'totalTasks') {
                    if (currentTotalTasksCompleted >= achievement.value) {
                        isAchieved = true;
                    }
                } else if (achievement.type === 'points') {
                    if (zPoint >= achievement.value) {
                        isAchieved = true;
                    }
                } else if (achievement.type === 'firstPin') {
                    if (hasPinnedTaskEver) {
                        isAchieved = true;
                    }
                }
                return isAchieved;
            }).length;

            const totalAchievements = achievementsData.length;

            // Format userCreationDate for display - CHANGED FORMAT HERE
            let formattedCreationDate = formatPersianDate(userCreationDate);


            // Prepare profile items as an array for dynamic rendering and responsive layout
            const profileItems = [
                { label: 'نام کاربری', value: userName || 'ناشناس', color: 'blue', icon: 'fa-user' },
                { label: 'کل وظایف', value: totalTasks, color: 'green', icon: 'fa-list-check' },
                { label: 'وظایف تکمیل شده', value: completedTasksCount, color: 'teal', icon: 'fa-check-double' },
                { label: 'تعداد پوینت', value: zPoint, color: 'yellow', icon: 'fa-coins' },
                { label: 'سطح', value: level, color: 'orange', icon: levelPointsThresholds[level - 1].icon.replace('fa-solid ', '') }, /* Changed color to orange */
                { label: 'زنجیره', value: `${dailyStreak} روز`, color: 'orange', icon: 'fa-fire' },
                { label: 'بیشترین زنجیره', value: `${highestDailyStreak} روز`, color: 'pink', icon: 'fa-fire-alt' },
                { label: 'عمر کاربری', value: `${daysSinceCreation} روز`, color: 'sky', icon: 'fa-calendar-days' },
                { label: 'تعداد دستاوردها', value: `${achievedAchievementsCount}/${totalAchievements}`, color: 'indigo', icon: 'fa-trophy' }
            ];

            let profileItemsHtml = profileItems.map((item, index) => {
                const isLastItem = index === profileItems.length - 1;
                const isOddCount = profileItems.length % 2 !== 0;
                // Apply sm:col-span-2 if it's the last item and the total count is odd (for desktop view)
                const colSpanClass = isLastItem && isOddCount ? 'sm:col-span-2' : '';

                return `
                    <div class="p-3 rounded-lg bg-${item.color}-50 dark:bg-${item.color}-900 text-${item.color}-800 dark:text-${item.color}-200 flex items-center justify-between ${colSpanClass}">
                        <span class="font-semibold">${item.label}:</span>
                        <span>${item.value}</span>
                    </div>
                `;
            }).join('');

            // Add the new "آغاز سفر شما" section as a single column
            profileItemsHtml += `
                <div class="p-3 rounded-lg bg-gray-100 dark:bg-gray-700 text-gray-800 dark:text-gray-100 flex items-center justify-between col-span-full">
                    <span class="font-semibold">تاریخ شروع:</span>
                    <span>${formattedCreationDate}</span>
                </div>
            `;


            profileModalBody.innerHTML = `
                <div class="grid grid-cols-1 sm:grid-cols-2 gap-3 mb-4">
                    ${profileItemsHtml}
                </div>
            `;

            // No clickable items in profile modal anymore as full achievement list is removed
        });

        closeProfileModalBtn.addEventListener('click', () => {
            profileModalContent.classList.remove('opacity-100', 'scale-100');
            profileModalContent.classList.add('opacity-0', 'scale-95');
            setTimeout(() => {
                profileModal.classList.add('hidden');
            }, 50);
        });

        // Event listener for new Achievements menu item
        achievementsMenuItem.addEventListener('click', (e) => {
            e.preventDefault();
            menuDropdown.classList.add('hidden'); // Hide dropdown

            // Ensure gamification display is updated right before showing achievements
            updateGamificationDisplay();
            showAchievementsModal();
        });

        // Function to show Achievements Modal
        function showAchievementsModal() {
            achievementsModal.classList.remove('hidden');
            void achievementsModalContent.offsetWidth; // Force reflow
            achievementsModalContent.classList.remove('opacity-0', 'scale-95');
            achievementsModalContent.classList.add('opacity-100', 'scale-100');

            renderAchievementsIntoModal(); // Render achievements when modal opens
        }

        // Event listener for closing Achievements Modal
        closeAchievementsModalBtn.addEventListener('click', () => {
            achievementsModalContent.classList.remove('opacity-100', 'scale-100');
            achievementsModalContent.classList.add('opacity-0', 'scale-95');
            setTimeout(() => {
                achievementsModal.classList.add('hidden');
            }, 50);
        });

        // Function to show Achievement Notification Modal (now uses queue)
        // This function is now internal and only pushes to the queue
        // The actual display logic is in processAchievementNotificationQueue()
        function showAchievementNotificationModal(iconClass, title, message) {
            showMessageBox(title, 'success', { type: 'achievement', iconClass: iconClass, description: message });
        }

        // Event listener for closing Achievement Notification Modal
        closeAchievementNotificationModalBtn.addEventListener('click', () => {
            achievementNotificationModalContent.classList.remove('opacity-100', 'scale-100');
            achievementNotificationModalContent.classList.add('opacity-0', 'scale-95');

            // Use setTimeout to ensure modal is visually hidden before processing next
            // The transition duration for achievementNotificationModalContent is 0.3s
            setTimeout(() => {
                achievementNotificationModal.classList.add('hidden'); // Fully hide the modal overlay
                isAchievementNotificationDisplaying = false; // Release the flag ONLY AFTER hiding
                // Call processAchievementNotificationQueue with a delay for the *next* modal
                setTimeout(() => { // NEW: Add 600ms delay here
                    processAchievementNotificationQueue(); // Process next in queue
                }, 600); // 600ms delay before showing next modal
            }, 350); // A little buffer after 300ms transition
        });


        helpMenuItem.addEventListener('click', (e) => {
            e.preventDefault();
            menuDropdown.classList.add('hidden'); // Hide dropdown

            // Show help modal with animation
            helpModal.classList.remove('hidden');
            void helpModalContent.offsetWidth; // Force reflow
            helpModalContent.classList.remove('opacity-0', 'scale-95');
            helpModalContent.classList.add('opacity-100', 'scale-100');

            // Dynamically update help modal content with current point values
            helpModalBody.innerHTML = `
                <h3 class="text-xl sm:text-2xl font-bold mb-2 help-heading-blue">به زای تسک خوش آمدید!</h3>
                <p class="semi-formal-text">زای تسک یک پلتفرم مدیریت وظایف گیمیفای شده است که با هدف افزایش انگیزه و بهره‌وری شما طراحی شده است. با انجام وظایف، پوینت کسب می‌کنید، سطح خود را ارتقا می‌دهید و دستاوردهای ویژه‌ای را باز می‌کنید.</p>

                <h3 class="text-xl sm:text-2xl font-bold mb-2 mt-4 help-heading-blue">نحوه استفاده از برنامه</h3>
                <p class="semi-formal-text">
                    <strong class="text-gray-600 dark:text-gray-300">۱. افزودن وظیفه جدید:</strong>
                    برای اضافه کردن یک وظیفه، نام آن را در فیلد "نام وظیفه" وارد کنید. سپس، می‌توانید اهمیت آن را از طریق منوی کشویی "اهمیت" انتخاب کنید:
                    <ul class="list-disc list-inside mt-2 mb-2 text-justify">
                        <li class="semi-formal-text"><strong class="text-red-600 dark:text-red-300">مهم:</strong> وظایف با اولویت بالا که پوینت بیشتری به شما می‌دهند.</li>
                        <li class="semi-formal-text"><strong class="text-gray-600 dark:text-gray-300">عادی:</strong> وظایف روزمره با پوینت استاندارد.</li>
                        <li class="semi-formal-text"><strong class="text-blue-600 dark:text-blue-300">سفارشی:</strong> می‌توانید میزان پوینت دریافتی برای این وظیفه را (تا حداکثر ${MAX_CUSTOM_POINTS} پوینت) به صورت دستی وارد کنید.</li> <li class="semi-formal-text"><strong class="text-orange-600 dark:text-orange-300">یادداشت:</strong> این نوع وظایف برای ثبت نکات، ایده‌ها یا اطلاعاتی هستند که نیازی به تکمیل شدن ندارند و پوینت گیمیفیکیشن نمی‌دهند. حداکثر طول متن برای یادداشت‌ها ۱۵۰ کاراکتر است.</li>
                    </ul>
                </p>
                <p class="semi-formal-text">پس از وارد کردن اطلاعات، روی دکمه "افزودن وظیفه" کلیک کنید.</p>
                <p class="semi-formal-text">
                    <strong class="text-gray-600 dark:text-gray-300">۲. تکمیل وظیفه:</strong>
                    برای علامت زدن یک وظیفه به عنوان "تکمیل شده" (به جز یادداشت‌ها)، کافیست روی چک‌باکس کنار آن کلیک کنید. با این کار، وظیفه به بخش "وظایف تکمیل شده" منتقل می‌شود و پوینت‌های مربوطه به حساب شما اضافه می‌گردد.
                </p>
                <p class="semi-formal-text">
                    <strong class="text-gray-600 dark:text-gray-300">۳. ویرایش وظیفه:</strong>
                    برای تغییر نام یا اهمیت یک وظیفه فعال، روی آیکون سه نقطه (<i class="fa-solid fa-ellipsis-v"></i>) در کنار آن کلیک کرده و گزینه "ویرایش" را انتخاب کنید.
                </p>
                <p class="semi-formal-text">
                    <strong class="text-gray-600 dark:text-gray-300">۴. حذف وظیفه:</strong>
                    برای حذف یک وظیفه (فعال یا تکمیل شده)، روی آیکون سه نقطه (<i class="fa-solid fa-ellipsis-v"></i>) کنار آن کلیک کرده و گزینه "حذف" را انتخاب کنید. پس از حذف، یک پیام "بازگردانی" برای مدت کوتاهی ظاهر می‌شود تا در صورت اشتباه، بتوانید وظیفه را برگردانید.
                </p>
                <p class="semi-formal-text">
                    <strong class="text-gray-600 dark:text-gray-300">۵. تغییر چیدمان وظایف:</strong>
                    برای تغییر دستی ترتیب وظایف فعال، روی آیکون سه نقطه (<i class="fa-solid fa-arrows-up-down"></i>) کنار وظیفه مورد نظر کلیک کرده و "تغییر چیدمان" را انتخاب کنید. سپس با استفاده از فلش‌های بالا و پایین، موقعیت وظیفه را جابجا کنید. پس از اتمام، دکمه "پایان" را فشار دهید.
                </p>
                <p class="semi-formal-text">
                    <strong class="text-gray-600 dark:text-gray-300">۶. پین کردن وظیفه:</strong>
                    می‌توانید وظایف مهم را به بالای لیست وظایف فعال "پین" کنید. برای این کار، روی آیکون سه نقطه (<i class="fa-solid fa-thumbtack"></i>) کنار وظیفه کلیک کرده و "پین کردن" را انتخاب کنید. وظایف پین شده همیشه در ابتدای لیست نمایش داده می‌شوند.
                </p>
                <p class="semi-formal-text">
                    <strong class="text-gray-600 dark:text-gray-300">۷. مشاهده وظایف تکمیل شده:</strong>
                    برای نمایش یا پنهان کردن لیست وظایف تکمیل شده، روی دکمه "وظایف تکمیل شده" در پایین صفحه کلیک کنید.
                </p>

                <h3 class="text-xl sm:text-2xl font-bold mb-2 mt-4 help-heading-blue">سیستم گیمیفیکیشن</h3> <p class="semi-formal-text">
                    <strong class="text-gray-600 dark:text-gray-300">پوینت:</strong>
                    پوینت‌ها نمادین هستند و میزان فعالیت و پیشرفت شما را نشان می‌دهند.
                    <ul class="list-disc list-inside mt-2 mb-2 text-justify">
                        <li class="semi-formal-text">وظایف عادی: ${pointsPerNormalTask} پوینت</li>
                        <li class="semi-formal-text">وظایف مهم: ${pointsPerImportantTask} پوینت</li>
                        <li class="semi-formal-text">وظایف سفارشی: تا ${MAX_CUSTOM_POINTS} پوینت (بر اساس مقدار وارد شده)</li>
                        <li class="semi-formal-text"><strong class="text-orange-600 dark:text-orange-300">یادداشت:</strong> این نوع وظایف برای ثبت نکات، ایده‌ها یا اطلاعاتی هستند که نیازی به تکمیل شدن ندارند و پوینت گیمیفیکیشن نمی‌دهند. حداکثر طول متن برای یادداشت‌ها ۱۵۰ کاراکتر است.</li>
                    </ul>
                </p>
                <p class="semi-formal-text">
                    <strong class="text-gray-600 dark:text-gray-300">سطوح:</strong> با کسب پوینت، به سطوح بالاتر صعود خواهید کرد. هر سطح جدید، یک نام و آیکون منحصر به فرد دارد. می‌توانید با کلیک بر روی نمایشگر سطح در بالای صفحه، جزئیات هر سطح را مشاهده کنید. در زیر لیست تمامی سطوح را مشاهده می‌کنید:
                </p>
                <div id="helpLevelsContainer" class="flex flex-wrap gap-2 mt-1 mb-4">
                    </div>
                <p class="semi-formal-text">
                    <strong class="text-gray-600 dark:text-gray-300">زنجیره روزانه:</strong>
                    با تکمیل حداقل یک وظیفه در هر روز، "زنجیره روزانه" شما افزایش می‌یابد. حفظ این زنجیره به شما کمک می‌کند تا عادت‌های مثبت بسازید و دستاوردهای ویژه‌ای کسب کنید. اگر یک روز وظیفه‌ای تکمیل نکنید، زنجیره بازنشانی می‌شود.
                </p>
                <p class="semi-formal-text">
                    <strong class="text-gray-600 dark:text-gray-300">دستاوردها:</strong> زای تسک دارای مجموعه‌ای از دستاوردها است که با رسیدن به نقاط عطف خاصی (مانند تکمیل تعداد مشخصی وظیفه، رسیدن به سطح خاص، یا حفظ زنجیره روزانه) باز می‌شوند. می‌توانید تمام دستاوردهای خود را از طریق منوی اصلی (آیکون سه نقطه در بالا سمت چپ) و انتخاب "دستاوردها" مشاهده کنید. دستاوردهای بازنشده به صورت قفل نمایش داده می‌شوند. در زیر لیست تمامی دستاوردها را مشاهده می‌کنید:
                </p>
                <div id="helpAchievementsContainer" class="flex flex-wrap gap-2 mt-1 mb-4">
                    </div>

                <h3 class="text-xl sm:text-2xl font-bold mb-2 mt-4 help-heading-blue">پشتیبان‌گیری و بازیابی داده‌ها</h3>
                <p class="semi-formal-text">
                    <strong class="text-gray-600 dark:text-gray-300">امنیت داده‌ها:</strong>
                    تمام داده‌های شما به صورت امن و فقط در حافظه محلی مرورگر شما ذخیره می‌شوند و هیچ اطلاعاتی به هیچ سروری ارسال نمی‌شود. این به معنای حریم خصوصی کامل است، اما مسئولیت پشتیبان‌گیری از داده‌ها با خود شماست.
                </p>
                <p class="semi-formal-text">
                    <strong class="text-gray-600 dark:text-gray-300">پشتیبان‌گیری (خروجی گرفتن):</strong>
                    برای ایجاد یک نسخه پشتیبان از داده‌های خود، از منوی اصلی، گزینه "پشتیبان‌گیری" را انتخاب کرده و سپس روی دکمه "ذخیره داده‌ها" کلیک کنید. یک فایل JSON حاوی تمام وظایف، پوینت‌ها، سطح و دستاوردهای شما دانلود خواهد شد. این فایل را در مکانی امن نگهداری کنید.
                </p>
                <p class="semi-formal-text">
                    <strong class="text-gray-600 dark:text-gray-300">بازیابی (ورودی گرفتن):</strong>
                    برای بازیابی داده‌ها از یک فایل پشتیبان، در همان بخش "پشتیبان‌گیری"، روی "انتخاب فایل" کلیک کرده و فایل JSON پشتیبان خود را انتخاب کنید. سپس "بارگذاری از فایل" را فشار دهید. این کار داده‌های فعلی برنامه شما را با داده‌های موجود در فایل جایگزین می‌کند.
                </p>

                <h3 class="text-xl sm:text-2xl font-bold mb-2 mt-4 help-heading-blue">بروزرسانی برنامه</h3>
                <p class="semi-formal-text">
                    این برنامه از <strong class="text-gray-600 dark:text-gray-300">سرویس پس‌زمینه (Service Worker)</strong> برای ارائه تجربه آفلاین و بارگذاری سریع استفاده می‌کند. برای اطمینان از اینکه همیشه آخرین نسخه برنامه را دارید و از جدیدترین ویژگی‌ها بهره‌مند می‌شوید، می‌توانید روی گزینه "بروزرسانی برنامه" در منوی اصلی کلیک کنید. این کار کش برنامه را پاک کرده و آخرین نسخه را از سرور بارگذاری می‌کند.
                </p>

                <h3 class="text-xl sm:text-2xl font-bold mb-2 mt-4 help-heading-blue">حمایت مالی</h3>
                <p class="semi-formal-text text-center">
                    این بخش در حال حاضر غیرفعال است. از علاقه شما سپاسگزاریم!
                </p>

                <p class="semi-formal-text text-center">
                    هدف زای تسک ایجاد انگیزه و کمک به سازماندهی بهتر وظایف شماست. امیدواریم از استفاده از آن لذت ببرید و در مسیر موفقیت خود پیشرفت کنید!
                </p>
            `;
            // Call renderHelpSpinners to populate levels and achievements
            renderHelpSpinners();
        });

        closeHelpModalBtn.addEventListener('click', () => {
            helpModalContent.classList.remove('opacity-100', 'scale-100');
            helpModalContent.classList.add('opacity-0', 'scale-95');
            setTimeout(() => {
                helpModal.classList.add('hidden');
            }, 50);
        });

        // New function to dynamically render levels and achievements in the help modal
        function renderHelpSpinners() {
            const helpLevelsContainer = document.getElementById('helpLevelsContainer');
            const helpAchievementsContainer = document.getElementById('helpAchievementsContainer');

            if (!helpLevelsContainer || !helpAchievementsContainer) return; // Ensure elements exist

            helpLevelsContainer.innerHTML = ''; // Clear previous content
            helpAchievementsContainer.innerHTML = ''; // Clear previous content

            // Render Levels (with icons)
            levelPointsThresholds.forEach((levelInfo, index) => {
                const levelSpan = document.createElement('span');
                levelSpan.className = `clickable-badge level-badge`;
                levelSpan.innerHTML = `<i class="${levelInfo.icon} ml-2"></i><span>سطح ${index + 1}: ${levelInfo.name}</span>`; // Icon added
                levelSpan.onclick = () => showDetailModal('level', levelInfo.name); // Pass name for level
                helpLevelsContainer.appendChild(levelSpan);
            });

            // Render Achievements (with icons)
            // Sort achievements by type and then value/level for consistent display
            const sortedAchievementsForHelp = [...achievementsData].sort((a, b) => {
                // Prioritize level achievements, then streak, then totalTasks, then points, then firstPin
                const typeOrder = { 'level': 0, 'streak': 1, 'totalTasks': 2, 'points': 3, 'firstPin': 4 };
                if (typeOrder[a.type] !== typeOrder[b.type]) {
                    return typeOrder[a.type] - typeOrder[b.type];
                }
                // For same type, sort by value or level
                if (a.type === 'level') return a.level - b.level;
                return (a.value || 0) - (b.value || 0);
            });

            sortedAchievementsForHelp.forEach(achievement => {
                const achievementSpan = document.createElement('span');
                achievementSpan.className = `clickable-badge achievement-badge`;
                achievementSpan.innerHTML = `<i class="${achievement.icon} ml-2"></i><span>${achievement.name}</span>`; // Icon added
                achievementSpan.onclick = () => showDetailModal('achievement', achievement.name);
                helpAchievementsContainer.appendChild(achievementSpan);
            });
        }


        aboutMenuItem.addEventListener('click', (e) => {
            e.preventDefault();
            menuDropdown.classList.add('hidden'); // Hide dropdown

            // Show about modal with animation
            aboutModal.classList.remove('hidden');
            void aboutModalContent.offsetWidth; // Force reflow
            aboutModalContent.classList.remove('opacity-0', 'scale-95');
            aboutModalContent.classList.add('opacity-100', 'scale-100');

            aboutModalBody.innerHTML = `
                <p class="semi-formal-text">این برنامه به منظور مدیریت وظایف و افزایش انگیزه طراحی شده است.</p>
                <p class="semi-formal-text">این پروژه به صورت اختصاصی توسط <strong class="text-gray-600 dark:text-gray-300"><a href="https://amuleo.ir" target="_blank" rel="noopener noreferrer">سایت عمو لئو</a></strong> طراحی شده است. این نسخه، اولین و آخرین نسخه از این پروژه است.</p>
                <div class="semi-formal-text text-justify mt-4 mb-4">
                    <p>برای ساخت این برنامه، 8 روز از مهم‌ترین روزهای عمرم صرف شد. روزهایی که امتحان داشتم، اما ۲۴ ساعت تمرکزم روی این پروژه بود و روزی ۱۶ ساعت، معادل 16 روز کاری روی این پروژه کار کردم. این پروژه بیش از ۲۰۰ یا ۳۰۰ بار دیباگ شده تا متناسب با هر صفحه نمایشی واکنش‌گرا باشد. برای همین، این پروژه پایان و خداحافظی من از دنیای برنامه‌نویسی است و دیگر این سایت آپدیت نمی‌شود.</p>
                </div>
                <p class="semi-formal-text">تمامی حقوق متعلق به <strong class="text-gray-600 dark:text-gray-300"><a href="https://amuleo.ir" target="_blank" rel="noopener noreferrer">عمو لئو</a></strong> است.</p>
                <p class="semi-formal-text">تاریخ: 9 خرداد ۱۴۰۴</p>
            `;
        });

        closeAboutModalBtn.addEventListener('click', () => {
            aboutModalContent.classList.remove('opacity-100', 'scale-100');
            aboutModalContent.classList.add('opacity-0', 'scale-95');
            setTimeout(() => {
                aboutModal.classList.add('hidden');
            }, 50);
        });

        backupMenuItem.addEventListener('click', (e) => {
            e.preventDefault();
            menuDropdown.classList.add('hidden'); // Hide dropdown

            // Show backup modal with animation
            backupModal.classList.remove('hidden');
            void backupModalContent.offsetWidth; // Force reflow
            backupModalContent.classList.remove('opacity-0', 'scale-95');
            backupModalContent.classList.add('opacity-100', 'scale-100');

            importFileInput.value = ''; // Clear file input on open
            selectedFileNameSpan.textContent = 'فایلی انتخاب نشده است.';
        });

        // Add listener for backup modal close button
        closeBackupModalBtn.addEventListener('click', () => {
            backupModalContent.classList.remove('opacity-100', 'scale-95');
            backupModalContent.classList.add('opacity-0', 'scale-95');
            setTimeout(() => {
                backupModal.classList.add('hidden');
            }, 50);
        });

        // New: Update App menu item functionality (now shows confirmation modal first)
        updateAppMenuItem.addEventListener('click', async (e) => {
            e.preventDefault();
            menuDropdown.classList.add('hidden'); // Hide dropdown

            // Show update confirmation modal
            updateConfirmModal.classList.remove('hidden');
            void updateConfirmModalContent.offsetWidth; // Force reflow
            updateConfirmModalContent.classList.remove('opacity-0', 'scale-95');
            updateConfirmModalContent.classList.add('opacity-100', 'scale-100');
        });

        // Event listener for "Confirm Update" button in the new modal
        confirmUpdateBtn.addEventListener('click', async () => {
            // Hide confirmation modal
            updateConfirmModalContent.classList.remove('opacity-100', 'scale-100');
            updateConfirmModalContent.classList.add('opacity-0', 'scale-95');
            setTimeout(() => {
                updateConfirmModal.classList.add('hidden');
            }, 50);

            if ('serviceWorker' in navigator) {
                try {
                    const registration = await navigator.serviceWorker.getRegistration();
                    if (registration && registration.active) {
                        showMessageBox('بروزرسانی برنامه آغاز شد. لطفاً صبر کنید...', 'info');
                        // Send message to active service worker to clear caches and reload
                        registration.active.postMessage({ type: 'START_DEEP_UPDATE' });

                        // Listen for message from service worker indicating reload is ready
                        navigator.serviceWorker.addEventListener('message', (event) => {
                            if (event.data && event.data.type === 'PERFORM_LOCAL_STORAGE_CLEANUP_AND_RELOAD') {
                                // Service worker has cleared its caches and unregistered itself.
                                // Now, perform localStorage cleanup and reload the page.
                                performLocalStorageCleanupAndReload(event.data.keysToPreserve);
                            }
                        }, { once: true });

                    } else {
                        // If no active service worker, try to unregister any existing ones
                        // and then reload. This is a fallback for a clean slate.
                        const registrations = await navigator.serviceWorker.getRegistrations();
                        await Promise.all(registrations.map(reg => reg.unregister()));
                        showMessageBox('Service Worker یافت نشد یا غیرفعال بود. کش مرورگر پاک شده و صفحه مجدداً بارگذاری می‌شود.', 'info');
                        // Clear all caches for good measure if no service worker was active
                        const cacheNames = await caches.keys();
                        await Promise.all(cacheNames.map(cacheName => caches.delete(cacheName)));
                        setTimeout(() => {
                            window.location.reload(); // Force a hard reload
                        }, 500);
                    }
                } catch (error) {
                    console.error('بروزرسانی Service Worker با خطا مواجه شد:', error);
                    showMessageBox('خطا در بروزرسانی برنامه. لطفاً دوباره امتحان کنید.', 'error');
                }
            } else {
                showMessageBox('مرورگر شما از سرویس پس‌زمینه (Service Worker) پشتیبانی نمی‌کند.', 'info');
            }
        });

        // Event listener for "Cancel Update" button in the new modal
        cancelUpdateBtn.addEventListener('click', () => {
            updateConfirmModalContent.classList.remove('opacity-100', 'scale-100');
            updateConfirmModalContent.classList.add('opacity-0', 'scale-95');
            setTimeout(() => {
                updateConfirmModal.classList.add('hidden');
            }, 50);
            showMessageBox('بروزرسانی برنامه لغو شد.', 'info');
        });

        // Event listener for closing the update confirmation modal
        closeUpdateModalBtn.addEventListener('click', () => {
            updateConfirmModalContent.classList.remove('opacity-100', 'scale-100');
            updateConfirmModalContent.classList.add('opacity-0', 'scale-95');
            setTimeout(() => {
                updateConfirmModal.classList.add('hidden');
            }, 50);
        });


        // Function to perform localStorage cleanup and reload (called by Service Worker)
        function performLocalStorageCleanupAndReload(keysToPreserve) {
            const preservedData = {};
            // Save data for keys to preserve
            keysToPreserve.forEach(key => {
                const value = localStorage.getItem(key);
                if (value !== null) {
                    preservedData[key] = value;
                }
            });

            localStorage.clear(); // Clear all localStorage

            // Restore preserved data
            for (const key in preservedData) {
                localStorage.setItem(key, preservedData[key]);
            }

            showMessageBox('برنامه بروزرسانی شد! صفحه در حال بارگذاری مجدد است.', 'success');
            setTimeout(() => {
                window.location.reload(); // Force a hard reload
            }, 500); // Give a small delay for message to be seen
        }


        donateMenuItem.addEventListener('click', (e) => {
            e.preventDefault();
            showMessageBox('این بخش در حال حاضر غیرفعال است. از علاقه شما سپاسگزاریم!', 'info');
            menuDropdown.classList.add('hidden'); // Hide dropdown after selection
        });

        resetMenuItem.addEventListener('click', (e) => {
            e.preventDefault();
            menuDropdown.classList.add('hidden'); // Hide dropdown

            // Show reset confirmation modal with animation
            resetConfirmModal.classList.remove('hidden');
            void resetConfirmModalContent.offsetWidth; // Force reflow
            resetConfirmModalContent.classList.remove('opacity-0', 'scale-95');
            resetConfirmModalContent.classList.add('opacity-100', 'scale-100');
        });

        confirmResetBtn.addEventListener('click', () => {
            localStorage.clear(); // Clear all data from local storage
            location.reload(); // Reload the page to reset the application
        });

        cancelResetBtn.addEventListener('click', () => {
            resetConfirmModalContent.classList.remove('opacity-100', 'scale-100');
            resetConfirmModalContent.classList.add('opacity-0', 'scale-95');
            setTimeout(() => {
                resetConfirmModal.classList.add('hidden');
            }, 50);
        });

        closeResetModalBtn.addEventListener('click', () => {
            resetConfirmModalContent.classList.remove('opacity-100', 'scale-100');
            resetConfirmModalContent.classList.add('opacity-0', 'scale-95');
            setTimeout(() => {
                resetConfirmModal.classList.add('hidden');
            }, 50);
        });

        // Welcome modal logic
        startBtn.addEventListener('click', () => {
            const inputName = userNameInput.value.trim();
            if (inputName.length === 0) {
                showMessageBox('لطفاً نام خود را وارد کنید.', 'info');
                return;
            }
            if (inputName.length > 15) {
                showMessageBox('مقدار ورودی نباید بیش از ۱۵ کاراکتر باشد.', 'error');
                return;
            }

            userName = inputName;
            if (!userCreationDate) { // Set user creation date only if it's not already set
                userCreationDate = new Date().toISOString();
            }
            saveToLocalStorage();
            welcomeModalContent.classList.remove('opacity-100', 'scale-100');
            welcomeModalContent.classList.add('opacity-0', 'scale-95');
            setTimeout(() => {
                welcomeModal.classList.add('hidden');
                updateGamificationDisplay(); // Call here after userName is set
                startMotivationRotation(); // <-- ADDED THIS LINE HERE
                // Add a small delay before processing notifications after welcome modal closes
                setTimeout(() => {
                    processNotificationQueue(); // Start processing general notifications
                    processAchievementNotificationQueue(); // Also process achievement queue on load
                }, 100); // 100ms delay
            }, 50);
            showMessageBox(`${userName} عزیز، خوش آمدید!`, 'success');
        });

        // Export data (download as file)
        exportDataBtn.addEventListener('click', () => {
            const dataToSave = {
                tasks: tasks,
                zPoint: zPoint,
                level: level,
                dailyStreak: dailyStreak,
                highestDailyStreak: highestDailyStreak, // Include highest streak in export
                lastCompletionDate: lastCompletionDate,
                totalCustomTasksCompleted: totalCustomTasksCompleted,
                userName: userName,
                userCreationDate: userCreationDate, // Include user creation date in export
                unlockedAchievements: unlockedAchievements, // Include unlocked achievements in export
                achievementUnlockDates: achievementUnlockDates, // Include achievement unlock dates in export
                hasPinnedTaskEver: hasPinnedTaskEver, // Include new flag in export
                currentMotivationIndex: currentMotivationIndex, // Include motivation index
                theme: localStorage.getItem('theme') // Include theme in export
            };
            const jsonString = JSON.stringify(dataToSave, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            const date = new Date();
            const dateString = `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}-${date.getDate().toString().padStart(2, '0')}`;
            a.download = `tasks_backup_${dateString}_zaytechtappy.json`; /* Updated filename */
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url); // Clean up URL object
            showMessageBox('فایل پشتیبان با موفقیت دانلود شد!', 'success');
        });

        // Update selected file name display
        importFileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                selectedFileNameSpan.textContent = e.target.files[0].name;
            } else {
                selectedFileNameSpan.textContent = 'فایلی انتخاب نشده است.';
            }
        });

        // Import data (load from file)
        importDataBtn.addEventListener('click', () => {
            const file = importFileInput.files[0];
            if (!file) {
                showMessageBox('لطفاً یک فایل پشتیبان برای بارگذاری انتخاب کنید.', 'info');
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const dataString = e.target.result;
                    const importedData = JSON.parse(dataString);

                    // --- Robust Data Assignment and Validation ---
                    // Initialize with current defaults to ensure all properties exist
                    tasks = [];
                    zPoint = 0;
                    level = 1;
                    dailyStreak = 0;
                    highestDailyStreak = 0;
                    lastCompletionDate = null;
                    totalCustomTasksCompleted = 0;
                    userName = null;
                    userCreationDate = null;
                    unlockedAchievements = [];
                    achievementUnlockDates = {};
                    hasPinnedTaskEver = false;
                    currentMotivationIndex = 0; // Initialize for import
                    let importedTheme = null;

                    // Assign properties with robust type checking and fallbacks
                    if (importedData && typeof importedData === 'object') {
                        if (Array.isArray(importedData.tasks)) {
                            tasks = importedData.tasks.map(task => ({
                                id: typeof task.id === 'string' ? task.id : Date.now().toString() + Math.random().toString().substring(2, 8), // Ensure unique ID
                                name: typeof task.name === 'string' ? task.name : 'وظیفه نامشخص',
                                completed: typeof task.completed === 'boolean' ? task.completed : false,
                                importance: typeof task.importance === 'string' && ['important', 'normal', 'custom', 'note'].includes(task.importance) ? task.importance : 'normal',
                                customPoints: typeof task.customPoints === 'number' ? task.customPoints : undefined,
                                isPinned: typeof task.isPinned === 'boolean' ? task.isPinned : false,
                                pinnedAt: typeof task.pinnedAt === 'string' || task.pinnedAt === null ? task.pinnedAt : null
                            }));
                        }

                        if (typeof importedData.zPoint === 'number') {
                            zPoint = importedData.zPoint;
                        } else {
                            zPoint = 0; // Default if not a number
                        }
                        if (typeof importedData.level === 'number') {
                            level = importedData.level;
                        } else {
                            level = 1; // Default if not a number
                        }
                        if (typeof importedData.dailyStreak === 'number') {
                            dailyStreak = importedData.dailyStreak;
                        } else {
                            dailyStreak = 0; // Default if not a number
                        }
                        if (typeof importedData.highestDailyStreak === 'number') {
                            highestDailyStreak = importedData.highestDailyStreak;
                        } else {
                            highestDailyStreak = 0; // Default if not a number
                        }
                        if (typeof importedData.lastCompletionDate === 'string' || importedData.lastCompletionDate === null) {
                            lastCompletionDate = importedData.lastCompletionDate;
                        } else {
                            lastCompletionDate = null; // Default if invalid
                        }
                        if (typeof importedData.totalCustomTasksCompleted === 'number') {
                            totalCustomTasksCompleted = importedData.totalCustomTasksCompleted;
                        } else {
                            totalCustomTasksCompleted = 0; // Default if not a number
                        }
                        if (typeof importedData.userName === 'string' || importedData.userName === null) {
                            userName = importedData.userName;
                        } else {
                            userName = null; // Default if invalid
                        }
                        if (typeof importedData.userCreationDate === 'string' || importedData.userCreationDate === null) {
                            userCreationDate = importedData.userCreationDate;
                        } else {
                            userCreationDate = null; // Default if invalid
                        }
                        if (Array.isArray(importedData.unlockedAchievements)) {
                            unlockedAchievements = importedData.unlockedAchievements;
                        } else {
                            unlockedAchievements = []; // Default if invalid
                        }
                        if (typeof importedData.achievementUnlockDates === 'object' && importedData.achievementUnlockDates !== null) {
                            achievementUnlockDates = importedData.achievementUnlockDates;
                        } else {
                            achievementUnlockDates = {}; // Default if invalid
                        }
                        if (typeof importedData.hasPinnedTaskEver === 'boolean') {
                            hasPinnedTaskEver = importedData.hasPinnedTaskEver;
                        } else {
                            hasPinnedTaskEver = false; // Default if invalid
                        }
                        if (typeof importedData.currentMotivationIndex === 'number') {
                            currentMotivationIndex = importedData.currentMotivationIndex;
                        } else {
                            currentMotivationIndex = 0; // Default if invalid
                        }
                        if (typeof importedData.theme === 'string') {
                            importedTheme = importedData.theme;
                        } else {
                            importedTheme = null; // Default if invalid
                        }
                    } else {
                        // If importedData is not an object, it's definitely invalid format
                        showMessageBox('فرمت داده‌های وارد شده نامعتبر است. لطفاً یک فایل پشتیبان معتبر را وارد کنید.', 'error');
                        return; // Stop execution
                    }

                    // Apply imported theme
                    if (importedTheme) {
                        localStorage.setItem('theme', importedTheme);
                        applyTheme(importedTheme);
                    } else {
                        localStorage.removeItem('theme'); // Clear theme if not present in backup
                        initializeTheme(); // Re-initialize based on system or default
                    }

                    saveToLocalStorage(); // Save imported data to local storage
                    updateDailyStreakOnImport(); // Re-evaluate daily streak based on imported data
                    renderTasks(); // Re-render UI with new data
                    updateMotivationQuote(false); // Update motivation quote immediately after import, without fade-out
                    startMotivationRotation(); // Restart motivation rotation

                    // Hide backup modal with animation
                    backupModalContent.classList.remove('opacity-100', 'scale-95');
                    backupModalContent.classList.add('opacity-0', 'scale-95');
                    setTimeout(() => {
                        backupModal.classList.add('hidden');
                    }, 50);
                    showMessageBox('داده‌ها با موفقیت بارگذاری شدند!', 'success');

                } catch (error) {
                    console.error("Error parsing imported data:", error);
                    showMessageBox('خطا در پردازش فایل وارد شده. اطمینان حاصل کنید که یک فایل JSON معتبر است.', 'error');
                }
            };
            reader.onerror = (e) => {
                console.error("Error reading file:", e);
                showMessageBox('خطا در خواندن فایل.', 'error');
            };
            reader.readAsText(file);
        });

        // Function to show detail modal for levels and achievements
        function showDetailModal(type, identifier) { // Removed dataArray as it's no longer needed
            detailModalTitle.textContent = '';
            detailModalBody.innerHTML = '';

            let contentHtml = '';
            let item;

            if (type === 'level') {
                const levelName = identifier; // Now identifier is the level name
                item = levelPointsThresholds.find(l => l.name === levelName);
                if (item) {
                    const unlockedDate = achievementUnlockDates[item.name];
                    // Changed date format here
                    const formattedDate = formatPersianDate(unlockedDate);

                    detailModalTitle.textContent = `سطح ${item.level || (levelPointsThresholds.indexOf(item) + 1)}: ${item.name}`;
                    contentHtml = `
                        <p class="semi-formal-text"><strong class="text-blue-600 dark:text-blue-300">توضیحات:</strong> ${item.motivational}</p>
                        <p class="semi-formal-text"><strong class="text-blue-600 dark:text-blue-300">پوینت مورد نیاز:</strong> ${item.points}</p>
                        <p class="semi-formal-text"><strong class="text-blue-600 dark:text-blue-300">تاریخ کسب:</strong> ${formattedDate}</p> `; // Icon removed
                } else {
                    detailModalTitle.textContent = 'سطح نامشخص';
                    contentHtml = '<p class="semi-formal-text">اطلاعاتی برای این سطح یافت نشد.</p>';
                }
            } else if (type === 'achievement') {
                const achievementName = identifier;
                item = achievementsData.find(ach => ach.name === achievementName);
                if (item) {
                    detailModalTitle.textContent = `دستاورد: ${item.name}`;
                    const isAchieved = unlockedAchievements.includes(item.name);
                    const unlockedDate = achievementUnlockDates[item.name];
                    // Changed date format here
                    const formattedDate = formatPersianDate(unlockedDate);

                    contentHtml = `
                        <p class="semi-formal-text"><strong class="text-blue-600 dark:text-blue-300">توضیحات:</strong> ${item.description}</p>
                        <p class="semi-formal-text"><strong class="text-blue-600 dark:text-blue-300">وضعیت:</strong> ${isAchieved ? 'باز شده' : 'باز نشده'}</p>
                        <p class="semi-formal-text"><strong class="text-blue-600 dark:text-blue-300">تاریخ باز شدن:</strong> ${formattedDate}</p> `; // Icon removed
                } else {
                    detailModalTitle.textContent = 'دستاورد نامشخص';
                    contentHtml = '<p class="semi-formal-text">اطلاعاتی برای این دستاورد یافت نشد.</p>';
                }
            }

            detailModalBody.innerHTML = contentHtml;

            detailModal.classList.remove('hidden');
            void detailModalContent.offsetWidth; // Force reflow
            detailModalContent.classList.remove('opacity-0', 'scale-95');
            detailModalContent.classList.add('opacity-100', 'scale-100');
        }

        closeDetailModalBtn.addEventListener('click', () => {
            detailModalContent.classList.remove('opacity-100', 'scale-100');
            detailModalContent.classList.add('opacity-0', 'scale-95');
            setTimeout(() => {
                detailModal.classList.add('hidden');
            }, 50);
        });

        // Function to update motivation quote with animation
        function updateMotivationQuote(animate = true) {
            console.log("Updating motivation quote. Current index:", currentMotivationIndex);
            console.log("Quote to display:", motivationQuotes[currentMotivationIndex]);
            if (animate) {
                motivationTextSpan.classList.add('animate-out');
                motivationTextSpan.addEventListener('animationend', function handler() {
                    motivationTextSpan.removeEventListener('animationend', handler);
                    motivationTextSpan.classList.remove('animate-out');
                    currentMotivationIndex = (currentMotivationIndex + 1) % motivationQuotes.length;
                    motivationTextSpan.textContent = motivationQuotes[currentMotivationIndex];
                    motivationTextSpan.classList.add('animate-in');
                    motivationTextSpan.addEventListener('animationend', function handler2() {
                        motivationTextSpan.removeEventListener('animationend', handler2);
                        motivationTextSpan.classList.remove('animate-in');
                    }, { once: true });
                }, { once: true });
            } else {
                motivationTextSpan.textContent = motivationQuotes[currentMotivationIndex];
                motivationTextSpan.classList.remove('animate-out', 'animate-in'); // Ensure no animation classes
                motivationTextSpan.style.opacity = '1';
                motivationTextSpan.style.transform = 'translateY(0)';
                currentMotivationIndex = (currentMotivationIndex + 1) % motivationQuotes.length; // Still increment index
            }
            saveToLocalStorage(); // Save the new index
        }

        // Function to start the motivation quote rotation
        function startMotivationRotation() {
            if (motivationInterval) {
                clearInterval(motivationInterval); // Clear any existing interval
            }
            // Initial display
            updateMotivationQuote(false); // Display first quote without animation on load
            motivationInterval = setInterval(updateMotivationQuote, 7000); // Change every 7 seconds
        }


        // Initial load and render
        window.onload = function () {
            let storedUserName = localStorage.getItem('userName');
            console.log("storedUserName on window.onload:", storedUserName); // Debugging
            if (storedUserName && storedUserName !== 'null') { // Check for 'null' string explicitly
                userName = storedUserName;
                console.log("userName set from localStorage:", userName); // Debugging
            } else {
                console.log("userName is null or 'null', showing welcomeModal"); // Debugging
                welcomeModal.classList.remove('hidden');
            }
            initializeTheme();
            loadFromLocalStorage(); // Keep this in case it does other necessary initializations
            console.log("userName after loadFromLocalStorage:", userName); // Debugging

            if (userName) { // Only render tasks and update gamification if userName is set
                renderTasks();
                updateGamificationDisplay(); // Call here for existing users
                startMotivationRotation(); // Start motivation rotation for existing users
                // Add a small delay before processing notifications on load for existing users
                setTimeout(() => {
                    processNotificationQueue(); // Start processing general notifications
                    processAchievementNotificationQueue(); // Also process achievement queue on load
                }, 100); // 100ms delay
            } else {
                // If userName is still null (e.g., first time user or cleared data), ensure welcome modal is visible and focus input
                welcomeModal.classList.remove('hidden');
                void welcomeModalContent.offsetWidth; // Force reflow
                welcomeModalContent.classList.remove('opacity-0', 'scale-95');
                welcomeModalContent.classList.add('opacity-100', 'scale-100');
                userNameInput.focus();
            }
        };


        // Register Service Worker for offline capability
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/service-worker.js')
                    .then(registration => {
                        console.log('Service Worker registered with scope:', registration.scope);
                        // Add a listener to detect when a new service worker is installed
                        registration.addEventListener('updatefound', () => {
                            const newWorker = registration.installing;
                            newWorker.addEventListener('statechange', () => {
                                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                    // A new service worker is installed and ready to take over
                                    // This is where you might prompt the user to refresh
                                    // showMessageBox('نسخه جدید برنامه موجود است. برای بروزرسانی صفحه را رفرش کنید.', 'info');
                                }
                            });
                        });
                    })
                    .catch(error => {
                        console.error('Service Worker registration failed:', error);
                    });
            });
        }

        // new code

      document.addEventListener('DOMContentLoaded', () => {
    // --- اینجا کدهای موجود برنامه اصلی شما (مثلاً مدیریت وظایف، امتیاز و ...) قرار می‌گیرد ---
    // این شامل تمامی توابع و متغیرهای اصلی برنامه شماست
    // مثال:
    // const tasks = JSON.parse(localStorage.getItem('tasks')) || [];
    // let zPoint = parseInt(localStorage.getItem('zPoint')) || 0;
    // function saveTasks() { /* ... */ }
    // function updatePoints(amount) { /* ... */ }
    // ... (بقیه کدهای موجود شما برای منطق اصلی برنامه) ...


    // Register Service Worker for offline capability
    if ('serviceWorker' in navigator) {
        navigator.serviceWorker.register('/service-worker.js')
            .then(registration => {
                console.log('Service Worker registered with scope:', registration.scope);
                registration.addEventListener('updatefound', () => {
                    const newWorker = registration.installing;
                    newWorker.addEventListener('statechange', () => {
                        if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                            // A new service worker is installed and ready to take over
                            // You might prompt the user to refresh here for updates
                            // showMessageBox('نسخه جدید برنامه موجود است. برای بروزرسانی صفحه را رفرش کنید.', 'info');
                        }
                    });
                });
            })
            .catch(error => {
                console.error('Service Worker registration failed:', error);
            });
    }

    // --- Start: Share and Manual Install Modal Functionality with Theming and Detailed Instructions ---

    const shareAppLink = document.getElementById('shareAppLink');
    const installAppLink = document.getElementById('installAppLink');

    // --- Dynamically Add Modal HTML to the body with theme colors and dark mode support ---
    const modalHtml = `
        <div id="installModal" class="fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center p-4 z-[9999] hidden">
            <div class="bg-white dark:bg-[#1f2937] rounded-lg shadow-xl p-6 w-full max-w-md text-right relative" style="direction: rtl;">
                <button id="closeModalBtn" class="absolute top-3 left-3 text-gray-400 hover:text-gray-600 dark:text-[#9ca3af] dark:hover:text-[#e5e7eb] focus:outline-none">
                    <i class="fas fa-times text-xl"></i>
                </button>
                <h2 class="text-xl font-bold mb-4 text-center text-[#1d4ed8] dark:text-[#2563eb]">نصب برنامه زای تسک</h2>
                <p class="text-sm text-gray-600 dark:text-[#9ca3af] mb-4 text-center">برای تجربه بهتر، برنامه را روی دستگاه خود نصب کنید:</p>
                <div id="installInstructions" class="space-y-4 text-gray-700 dark:text-[#e5e7eb]">
                    </div>
                <div class="mt-6 text-center">
                    <button id="understoodBtn" class="bg-[#2563eb] hover:bg-[#1d4ed8] text-white font-bold py-2 px-6 rounded-lg focus:outline-none focus:shadow-outline transition duration-200">
                        متوجه شدم
                    </button>
                </div>
            </div>
        </div>
    `;
    document.body.insertAdjacentHTML('beforeend', modalHtml);

    const installModal = document.getElementById('installModal');
    const closeModalBtn = document.getElementById('closeModalBtn');
    const understoodBtn = document.getElementById('understoodBtn');
    const installInstructions = document.getElementById('installInstructions');

    // Function to detect browser and platform (more refined)
    function getBrowserAndPlatform() {
        const userAgent = navigator.userAgent;
        let browser = 'Other';
        let platform = 'Desktop';
        let os = 'Unknown OS';

        // Detect Platform/OS first
        if (/windows/i.test(userAgent)) {
            os = 'Windows';
            platform = 'Desktop';
        } else if (/macintosh|mac os x/i.test(userAgent)) {
            os = 'macOS';
            platform = 'Desktop';
        } else if (/linux/i.test(userAgent)) {
            os = 'Linux';
            platform = 'Desktop';
        } else if (/android/i.test(userAgent)) {
            os = 'Android';
            platform = 'Mobile';
        } else if (/iphone|ipod/i.test(userAgent)) {
            os = 'iOS';
            platform = 'Mobile';
        } else if (/ipad/i.test(userAgent)) {
            os = 'iPadOS';
            platform = 'Tablet'; // Distinguish tablet for iPad-specific instructions
        }

        // Detect Browser
        if (userAgent.includes('CriOS')) browser = 'Chrome'; // Chrome on iOS
        else if (userAgent.includes('Chrome') && !userAgent.includes('Edge')) browser = 'Chrome'; // Chrome on Android/Desktop
        else if (userAgent.includes('Safari') && !userAgent.includes('Chrome')) browser = 'Safari'; // Safari on iOS/Desktop
        else if (userAgent.includes('Firefox')) browser = 'Firefox';
        else if (userAgent.includes('Edg') || userAgent.includes('Edge')) browser = 'Edge';
        else if (userAgent.includes('SamsungBrowser')) browser = 'Samsung Browser';
        else if (userAgent.includes('Brave')) browser = 'Brave';
        else if (userAgent.includes('Opera') || userAgent.includes('OPR')) browser = 'Opera';
        else if (userAgent.includes('MSIE') || userAgent.includes('Trident')) browser = 'Internet Explorer'; // Legacy IE
        else if (userAgent.includes('Bing')) browser = 'Bing'; // Bing app/browser, often Chromium-based

        return { browser, platform, os };
    }

    // Function to provide browser- and platform-specific instructions
    function getInstallInstructionsContent() {
        const { browser, platform, os } = getBrowserAndPlatform();
        let instructions = '';
        const blueIcon = 'text-[#2563eb] dark:text-[#1d4ed8]'; // Consistent icon color
        const grayIcon = 'text-gray-600 dark:text-[#9ca3af]'; // For less prominent icons

        const commonSafariiOS = `
            <p><strong class="text-[#1d4ed8] dark:text-[#2563eb]">در مرورگر سافاری (iOS/iPadOS):</strong></p>
            <ol class="list-decimal list-inside text-sm leading-relaxed">
                <li>روی دکمه <i class="fas fa-share-alt ${blueIcon}"></i> (Share) در نوار پایین مرورگر ضربه بزنید.</li>
                <li>به پایین اسکرول کنید و گزینه "<strong>Add to Home Screen</strong>" را انتخاب کنید.</li>
                <li>در پنجره باز شده، روی "Add" در بالا سمت راست ضربه بزنید.</li>
            </ol>
        `;

        switch (browser) {
            case 'Chrome':
            case 'Samsung Browser':
            case 'Brave': // Chromium-based browsers
                if (platform === 'Mobile' || platform === 'Tablet') {
                    instructions = `
                        <p><strong class="text-[#1d4ed8] dark:text-[#2563eb]">در مرورگر ${browser} (${os}):</strong></p>
                        <ol class="list-decimal list-inside text-sm leading-relaxed">
                            <li>روی آیکون سه نقطه <i class="fas fa-ellipsis-v ${blueIcon}"></i> یا سه خط <i class="fas fa-bars ${blueIcon}"></i> در بالای صفحه سمت چپ (منوی مرورگر) ضربه بزنید.</li>
                            <li>گزینه "<strong>Add to Home screen</strong>" یا "<strong>Install app</strong>" را پیدا کرده و انتخاب کنید.</li>
                            <li>دستورالعمل‌ها را دنبال کنید تا برنامه به صفحه اصلی شما اضافه شود.</li>
                        </ol>
                    `;
                } else { // Desktop Chrome/Brave
                    instructions = `
                        <p><strong class="text-[#1d4ed8] dark:text-[#2563eb]">در مرورگر ${browser} (دسکتاپ ${os}):</strong></p>
                        <ol class="list-decimal list-inside text-sm leading-relaxed">
                            <li>به دنبال آیکون "نصب برنامه" <i class="fas fa-download ${blueIcon}"></i> یا <i class="fas fa-plus ${blueIcon}"></i> در نوار آدرس مرورگر (معمولاً سمت راست) بگردید و روی آن کلیک کنید.</li>
                            <li>در پنجره باز شده، روی "<strong>Install</strong>" کلیک کنید.</li>
                        </ol>
                        <p class="text-sm mt-2 text-gray-600 dark:text-[#9ca3af]">یا از منوی مرورگر (سه نقطه <i class="fas fa-ellipsis-v ${grayIcon}"></i>) گزینه "Install ${document.title}..." را پیدا کنید.</p>
                    `;
                }
                break;
            case 'Safari':
                if (os === 'iOS' || os === 'iPadOS') {
                    instructions = commonSafariiOS;
                } else { // Desktop Safari (macOS)
                    instructions = `
                        <p><strong class="text-[#1d4ed8] dark:text-[#2563eb]">در مرورگر سافاری (دسکتاپ macOS):</strong></p>
                        <p class="text-sm">سافاری در دسکتاپ امکان نصب مستقیم برنامه (PWA) را ندارد. می‌توانید آدرس این صفحه را برای دسترسی سریع ذخیره کنید (Bookmark).</p>
                        <p class="text-sm mt-2 text-gray-600 dark:text-[#9ca3af]">اگر از آیفون یا آیپد استفاده می‌کنید، مراحل نصب متفاوت است:</p>
                        ${commonSafariiOS}
                    `;
                }
                break;
            case 'Firefox':
                if (platform === 'Mobile' || platform === 'Tablet') {
                    instructions = `
                        <p><strong class="text-[#1d4ed8] dark:text-[#2563eb]">در مرورگر فایرفاکس (موبایل ${os}):</strong></p>
                        <ol class="list-decimal list-inside text-sm leading-relaxed">
                            <li>روی آیکون سه نقطه <i class="fas fa-ellipsis-v ${blueIcon}"></i> (منو) در پایین صفحه ضربه بزنید.</li>
                            <li>گزینه "<strong>Install</strong>" را پیدا کرده و انتخاب کنید.</li>
                        </ol>
                    `;
                } else { // Desktop Firefox
                    instructions = `
                        <p><strong class="text-[#1d4ed8] dark:text-[#2563eb]">در مرورگر فایرفاکس (دسکتاپ ${os}):</strong></p>
                        <ol class="list-decimal list-inside text-sm leading-relaxed">
                            <li>به دنبال آیکون خانه با علامت مثبت <i class="fas fa-plus-circle ${blueIcon}"></i> یا نماد صفحه با فلش رو به پایین <i class="fas fa-arrow-alt-circle-down ${blueIcon}"></i> در نوار آدرس بگردید.</li>
                            <li>روی آن کلیک کنید و دستورالعمل‌ها را دنبال کنید.</li>
                        </ol>
                        <p class="text-sm mt-2 text-gray-600 dark:text-[#9ca3af]">یا از منوی مرورگر (سه خط <i class="fas fa-bars ${grayIcon}"></i>) گزینه "Install" را پیدا کنید.</p>
                    `;
                }
                break;
            case 'Edge':
            case 'Bing': // Bing browser app often uses Edge engine
                if (platform === 'Mobile' || platform === 'Tablet') {
                    instructions = `
                        <p><strong class="text-[#1d4ed8] dark:text-[#2563eb]">در مرورگر اج/بینگ (موبایل ${os}):</strong></p>
                        <ol class="list-decimal list-inside text-sm leading-relaxed">
                            <li>روی آیکون سه نقطه <i class="fas fa-ellipsis-h ${blueIcon}"></i> (منو) در پایین صفحه ضربه بزنید.</li>
                            <li>گزینه "<strong>Add to phone</strong>" یا "<strong>Install app</strong>" را پیدا کرده و انتخاب کنید.</li>
                        </ol>
                    `;
                } else { // Desktop Edge
                    instructions = `
                        <p><strong class="text-[#1d4ed8] dark:text-[#2563eb]">در مرورگر اج (دسکتاپ ${os}):</strong></p>
                        <ol class="list-decimal list-inside text-sm leading-relaxed">
                            <li>به دنبال آیکون "App available" <i class="fas fa-download ${blueIcon}"></i> یا دکمه "Install" در نوار آدرس مرورگر بگردید و روی آن کلیک کنید.</li>
                            <li>در پنجره باز شده، روی "<strong>Install</strong>" کلیک کنید.</li>
                        </ol>
                        <p class="text-sm mt-2 text-gray-600 dark:text-[#9ca3af]">یا از منوی مرورگر (سه نقطه <i class="fas fa-ellipsis-h ${grayIcon}"></i>) گزینه "Apps" سپس "Install this site as an app" را پیدا کنید.</p>
                    `;
                }
                break;
            case 'Opera':
                if (platform === 'Mobile' || platform === 'Tablet') {
                    instructions = `
                        <p><strong class="text-[#1d4ed8] dark:text-[#2563eb]">در مرورگر اپرا (موبایل ${os}):</strong></p>
                        <p class="text-sm">معمولاً می‌توانید برنامه را از طریق منوی مرورگر (آیکون اپرا <i class="fab fa-opera ${blueIcon}"></i> یا سه خط <i class="fas fa-bars ${blueIcon}"></i>) و جستجوی گزینه‌هایی مانند "<strong>Add to Home Screen</strong>" یا "<strong>Install app</strong>" نصب کنید.</p>
                    `;
                } else { // Desktop Opera
                    instructions = `
                        <p><strong class="text-[#1d4ed8] dark:text-[#2563eb]">در مرورگر اپرا (دسکتاپ ${os}):</strong></p>
                        <p class="text-sm">معمولاً می‌توانید برنامه را از طریق منوی مرورگر (آیکون اپرا <i class="fab fa-opera ${blueIcon}"></i>) و جستجوی گزینه‌هایی مانند "<strong>Install app</strong>" یا "<strong>Add to Home Screen</strong>" نصب کنید.</p>
                    `;
                }
                break;
            case 'Internet Explorer':
                instructions = `
                    <p><strong class="text-[#ef4444] dark:text-[#ef4444]">مرورگر شما، Internet Explorer، به طور کامل از نصب برنامه‌های PWA پشتیبانی نمی‌کند.</strong></p>
                    <p class="text-sm mt-2 text-gray-700 dark:text-[#e5e7eb]">برای بهترین تجربه، لطفاً از یک مرورگر مدرن مانند کروم، فایرفاکس یا اج استفاده کنید.</p>
                `;
                break;
            case 'Other':
            default:
                instructions = `
                    <p><strong class="text-[#1d4ed8] dark:text-[#2563eb]">راهنمای نصب برای مرورگر شما (${browser} ${platform} ${os}):</strong></p>
                    <p class="text-sm">معمولاً می‌توانید برنامه را از طریق منوی مرورگر (به دنبال آیکون سه نقطه <i class="fas fa-ellipsis-v ${blueIcon}"></i>، سه خط <i class="fas fa-bars ${blueIcon}"></i> یا آیکون اشتراک‌گذاری <i class="fas fa-share-alt ${blueIcon}"></i> بگردید) و جستجوی گزینه‌هایی مانند "<strong>Add to Home screen</strong>"، "<strong>Install app</strong>" یا "<strong>Install site</strong>" نصب کنید.</p>
                    <p class="text-sm mt-2 text-gray-600 dark:text-[#9ca3af]">اگر از آیفون یا آیپد استفاده می‌کنید و مرورگر شما سافاری است، از دستورالعمل زیر پیروی کنید:</p>
                    ${commonSafariiOS}
                `;
                break;
        }

        installInstructions.innerHTML = instructions;
        installModal.classList.remove('hidden'); // Show the modal
    }

    // --- Attach event listener to the "Install App" button ---
    installAppLink.addEventListener('click', (e) => {
        e.preventDefault();
        getInstallInstructionsContent(); // Call the function to show instructions
    });

    // --- Close Modal Event Listeners ---
    closeModalBtn.addEventListener('click', () => {
        installModal.classList.add('hidden');
    });
    understoodBtn.addEventListener('click', () => { // "متوجه شدم" button
        installModal.classList.add('hidden');
    });

    // Close modal if clicked outside (optional, but good UX)
    installModal.addEventListener('click', (e) => {
        if (e.target === installModal) {
            installModal.classList.add('hidden');
        }
    });

    // --- End: Share and Manual Install Modal Functionality ---


    // --- Start: Share Functionality (same as before) ---
    // The share button is initially hidden and shown only if navigator.share is supported
    if ('share' in navigator) {
        shareAppLink.classList.remove('hidden');
        shareAppLink.addEventListener('click', async (e) => {
            e.preventDefault();
            try {
                await navigator.share({
                    title: 'زای تسک',
                    text: 'برنامه مدیریت تسک‌ها را امتحان کنید!',
                    url: window.location.href
                });
                console.log('Action: Content shared successfully.');
            } catch (error) {
                console.error('Error sharing:', error);
            }
        });
    } else {
        shareAppLink.classList.add('hidden');
        console.warn('Warning: Web Share API is not supported in this browser.');
    }
    // --- End: Share Functionality ---

    // Optional: Hide install button if app is already installed
    // This part still relies on 'appinstalled' event, which works if the PWA was installed via browser's native prompt
    window.addEventListener('appinstalled', () => {
        console.log('Event: PWA was successfully installed (via native prompt).');
        // If the user installed via native prompt, hide *your* manual install button.
        installAppLink.classList.add('hidden');
    });

}); // End of DOMContentLoaded
        
        
    </script>
</body>
</html>
